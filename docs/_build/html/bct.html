<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>bct package &mdash; bct 0.4 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="bct 0.4 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">bct 0.4 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="bct-package">
<h1>bct package<a class="headerlink" href="#bct-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="bct-bct-module">
<h2>bct.bct module<a class="headerlink" href="#bct-bct-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="bct-nbs-module">
<h2>bct.nbs module<a class="headerlink" href="#bct-nbs-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-bct">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-bct" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="bct.BCTParamError">
<em class="property">exception </em><tt class="descclassname">bct.</tt><tt class="descname">BCTParamError</tt><a class="headerlink" href="#bct.BCTParamError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.RuntimeError</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="bct.adjacency_plot_und">
<tt class="descclassname">bct.</tt><tt class="descname">adjacency_plot_und</tt><big>(</big><em>A</em>, <em>coor</em>, <em>tube=False</em><big>)</big><a class="headerlink" href="#bct.adjacency_plot_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This function in matlab is a visualization helper which translates an
adjacency matrix and an Nx3 matrix of spatial coordinates, and plots a
3D isometric network connecting the undirected unweighted nodes using a
specific plotting format. Including the formatted output is not useful at
all for bctpy since matplotlib will not be able to plot it in quite the
same way.</p>
<p>Instead of doing this, I have included code that will plot the adjacency
matrix onto nodes at the given spatial coordinates in mayavi</p>
<p>This routine is basically a less featureful version of the 3D brain in
cvu, the connectome visualization utility which I also maintain. cvu uses 
freesurfer surfaces and annotations to get the node coordinates (rather     
than leaving them up to the user) and has many other interactive 
visualization features not included here for the sake of brevity.</p>
<p>There are other similar visualizations in the ConnectomeViewer and the 
UCLA multimodal connectivity database.</p>
<p>Note that unlike other bctpy functions, this function depends on mayavi.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>adjacency matrix</dd>
<dt>coor <span class="classifier-delimiter">:</span> <span class="classifier">Nx3 np.ndarray</span></dt>
<dd>vector of node coordinates</dd>
<dt>tube <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>plots using cylindrical tubes for higher resolution image. If True,
plots cylindrical tube sources. If False, plots line sources. Default
value is False.</dd>
</dl>
<dl class="docutils">
<dt>fig <span class="classifier-delimiter">:</span> <span class="classifier">Instance(Scene)</span></dt>
<dd>handle to a mayavi figure.</dd>
</dl>
<p>To display the output interactively, call</p>
<p>fig=adjacency_plot_und(A,coor)
from mayavi import mlab
mlab.show()</p>
<p>Note: Thresholding the matrix is strongly recommended.  It is recommended
that the input matrix have fewer than 5000 total connections in order to
achieve reasonable performance and noncluttered visualization.</p>
</dd></dl>

<dl class="function">
<dt id="bct.agreement">
<tt class="descclassname">bct.</tt><tt class="descname">agreement</tt><big>(</big><em>ci</em>, <em>buffsz=None</em><big>)</big><a class="headerlink" href="#bct.agreement" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes as input a set of vertex partitions CI of
dimensions [vertex x partition]. Each column in CI contains the
assignments of each vertex to a class/community/module. This function
aggregates the partitions in CI into a square [vertex x vertex]
agreement matrix D, whose elements indicate the number of times any two
vertices were assigned to the same class.</p>
<p>In the case that the number of nodes and partitions in CI is large
(greater than ~1000 nodes or greater than ~1000 partitions), the script
can be made faster by computing D in pieces. The optional input BUFFSZ
determines the size of each piece. Trial and error has found that
BUFFSZ ~ 150 works well.</p>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">NxM np.ndarray</span></dt>
<dd>set of (possibly degenerate) partitions</dd>
<dt>buffsz <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>sets buffer size. If not specified, defaults to 1000</dd>
</dl>
<dl class="docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>agreement matrix</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.agreement_weighted">
<tt class="descclassname">bct.</tt><tt class="descname">agreement_weighted</tt><big>(</big><em>ci</em>, <em>wts</em><big>)</big><a class="headerlink" href="#bct.agreement_weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>D = AGREEMENT_WEIGHTED(CI,WTS) is identical to AGREEMENT, with the 
exception that each partitions contribution is weighted according to 
the corresponding scalar value stored in the vector WTS. As an example,
suppose CI contained partitions obtained using some heuristic for 
maximizing modularity. A possible choice for WTS might be the Q metric
(Newman&#8217;s modularity score). Such a choice would add more weight to 
higher modularity partitions.</p>
<p>NOTE: Unlike AGREEMENT, this script does not have the input argument
BUFFSZ.</p>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">NxM np.ndarray</span></dt>
<dd>set of (possibly degenerate) partitions</dd>
<dt>wts <span class="classifier-delimiter">:</span> <span class="classifier">Mx1 np.ndarray</span></dt>
<dd>relative weight of each partition</dd>
</dl>
<dl class="docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted agreement matrix</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.align_matrices">
<tt class="descclassname">bct.</tt><tt class="descname">align_matrices</tt><big>(</big><em>m1</em>, <em>m2</em>, <em>dfun='sqrdiff'</em>, <em>verbose=False</em>, <em>H=1000000.0</em>, <em>Texp=1</em>, <em>T0=0.001</em>, <em>Hbrk=10</em><big>)</big><a class="headerlink" href="#bct.align_matrices" title="Permalink to this definition">¶</a></dt>
<dd><p>This function aligns two matrices relative to one another by reordering
the nodes in M2.  The function uses a version of simulated annealing.</p>
<dl class="docutils">
<dt>M1 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>first connection matrix</dd>
<dt>M2 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>second connection matrix</dd>
<dt>dfun <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><dl class="first last docutils">
<dt>distance metric to use for matching</dt>
<dd>&#8216;absdiff&#8217; : absolute difference
&#8216;sqrdiff&#8217; : squared difference (default)
&#8216;cosang&#8217; : cosine of vector angle</dd>
</dl>
</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>print out cost at each iteration. Default False.</dd>
<dt>H <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>annealing parameter, default value 1e6</dd>
<dt>Texp <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>annealing parameter, default value 1. Coefficient of H s.t. 
Texp0=1-Texp/H</dd>
<dt>T0 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>annealing parameter, default value 1e-3</dd>
<dt>Hbrk <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>annealing parameter, default value = 10. Coefficient of H s.t.
Hbrk0 = H/Hkbr</dd>
</dl>
<dl class="docutils">
<dt>Mreordered <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>reordered connection matrix M2</dd>
<dt>Mindices <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>reordered indices</dd>
<dt>cost <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>objective function distance between M1 and Mreordered</dd>
</dl>
<p>Connection matrices can be weighted or binary, directed or undirected.
They must have the same number of nodes.  M1 can be entered in any
node ordering.</p>
<p>Note that in general, the outcome will depend on the initial condition
(the setting of the random number seed).  Also, there is no good way to 
determine optimal annealing parameters in advance - these parameters 
will need to be adjusted &#8220;by hand&#8221; (particularly H, Texp, T0, and Hbrk).  
For large and/or dense matrices, it is highly recommended to perform 
exploratory runs varying the settings of &#8216;H&#8217; and &#8216;Texp&#8217; and then select 
the best values.</p>
<p>Based on extensive testing, it appears that T0 and Hbrk can remain
unchanged in most cases.  Texp may be varied from 1-1/H to 1-10/H, for
example.  H is the most important parameter - set to larger values as
the problem size increases.  Good solutions can be obtained for
matrices up to about 100 nodes.  It is advisable to run this function
multiple times and select the solution(s) with the lowest &#8216;cost&#8217;.</p>
<p>If the two matrices are related it may be very helpful to pre-align them
by reordering along their largest eigenvectors:</p>
<blockquote>
<div>[v,~] = eig(M1); v1 = abs(v(:,end)); [a1,b1] = sort(v1);
[v,~] = eig(M2); v2 = abs(v(:,end)); [a2,b2] = sort(v2);
[a,b,c] = overlapMAT2(M1(b1,b1),M2(b2,b2),&#8217;dfun&#8217;,1);</div></blockquote>
<p>Setting &#8216;Texp&#8217; to zero cancels annealing and uses a greedy algorithm
instead.</p>
</dd></dl>

<dl class="function">
<dt id="bct.assortativity_bin">
<tt class="descclassname">bct.</tt><tt class="descname">assortativity_bin</tt><big>(</big><em>CIJ</em>, <em>flag</em><big>)</big><a class="headerlink" href="#bct.assortativity_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>The assortativity coefficient is a correlation coefficient between the
degrees of all nodes on two opposite ends of a link. A positive
assortativity coefficient indicates that nodes tend to link to other
nodes with the same or similar degree.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed/undirected connection matrix</dd>
<dt>flag <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>0 : undirected graph; degree/degree correlation
1 : directed graph; out-degree/in-degree correlation
2 : directed graph; in-degree/out-degree correlation
3 : directed graph; out-degree/out-degree correlation
4 : directed graph; in-degree/in-degreen correlation</dd>
</dl>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>assortativity coefficient</dd>
</dl>
<p>Notes: The function accepts weighted networks, but all connection
weights are ignored. The main diagonal should be empty. For flag 1
the function computes the directed assortativity described in Rubinov
and Sporns (2010) NeuroImage.</p>
</dd></dl>

<dl class="function">
<dt id="bct.assortativity_wei">
<tt class="descclassname">bct.</tt><tt class="descname">assortativity_wei</tt><big>(</big><em>CIJ</em>, <em>flag</em><big>)</big><a class="headerlink" href="#bct.assortativity_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>The assortativity coefficient is a correlation coefficient between the
strengths (weighted degrees) of all nodes on two opposite ends of a link.
A positive assortativity coefficient indicates that nodes tend to link to
other nodes with the same or similar strength.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted directed/undirected connection matrix</dd>
<dt>flag <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>0 : undirected graph; strength/strength correlation
1 : directed graph; out-strength/in-strength correlation
2 : directed graph; in-strength/out-strength correlation
3 : directed graph; out-strength/out-strength correlation
4 : directed graph; in-strength/in-strengthn correlation</dd>
</dl>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>assortativity coefficient</dd>
<dt>Notes: The main diagonal should be empty. For flag 1</dt>
<dd>the function computes the directed assortativity described in Rubinov
and Sporns (2010) NeuroImage.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.autofix">
<tt class="descclassname">bct.</tt><tt class="descname">autofix</tt><big>(</big><em>W</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.autofix" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix a bunch of common problems. More specifically, remove Inf and NaN,
ensure exact binariness and symmetry (i.e. remove floating point
instability), and zero diagonal.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>weighted connectivity matrix</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</dd>
</dl>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>connectivity matrix with fixes applied</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.backbone_wu">
<tt class="descclassname">bct.</tt><tt class="descname">backbone_wu</tt><big>(</big><em>CIJ</em>, <em>avgdeg</em><big>)</big><a class="headerlink" href="#bct.backbone_wu" title="Permalink to this definition">¶</a></dt>
<dd><p>The network backbone contains the dominant connections in the network
and may be used to aid network visualization. This function computes
the backbone of a given weighted and undirected connection matrix CIJ, 
using a minimum-spanning-tree based algorithm.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted undirected connection matrix</dd>
<dt>avgdeg <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>desired average degree of backbone</dd>
</dl>
<dl class="docutils">
<dt>CIJtree <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix of the minimum spanning tree of CIJ</dd>
<dt>CIJclus <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix of the minimum spanning tree plus strongest
connections up to some average degree &#8216;avgdeg&#8217;. Identical to CIJtree
if the degree requirement is already met.</dd>
</dl>
<p>NOTE: nodes with zero strength are discarded.
NOTE: CIJclus will have a total average degree exactly equal to</p>
<blockquote>
<div>(or very close to) &#8216;avgdeg&#8217;.</div></blockquote>
<dl class="docutils">
<dt>NOTE: &#8216;avgdeg&#8217; backfill is handled slightly differently than in Hagmann</dt>
<dd>et al 2008.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.betweenness_bin">
<tt class="descclassname">bct.</tt><tt class="descname">betweenness_bin</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.betweenness_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Node betweenness centrality is the fraction of all shortest paths in 
the network that contain a given node. Nodes with high values of 
betweenness centrality participate in a large number of shortest paths.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed/undirected connection matrix</dd>
<dt>BC <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node betweenness centrality vector</dd>
</dl>
<p>Note: Betweenness centrality may be normalised to the range [0,1] as
BC/[(N-1)(N-2)], where N is the number of nodes in the network.</p>
</dd></dl>

<dl class="function">
<dt id="bct.betweenness_wei">
<tt class="descclassname">bct.</tt><tt class="descname">betweenness_wei</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.betweenness_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Node betweenness centrality is the fraction of all shortest paths in 
the network that contain a given node. Nodes with high values of 
betweenness centrality participate in a large number of shortest paths.</p>
<dl class="docutils">
<dt>L <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed/undirected weighted connection matrix</dd>
<dt>BC <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node betweenness centrality vector</dd>
<dt>Notes:</dt>
<dd><dl class="first last docutils">
<dt>The input matrix must be a connection-length matrix, typically</dt>
<dd>obtained via a mapping from weight to length. For instance, in a
weighted correlation network higher correlations are more naturally
interpreted as shorter distances and the input matrix should
consequently be some inverse of the connectivity matrix.</dd>
<dt>Betweenness centrality may be normalised to the range [0,1] as</dt>
<dd>BC/[(N-1)(N-2)], where N is the number of nodes in the network.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.binarize">
<tt class="descclassname">bct.</tt><tt class="descname">binarize</tt><big>(</big><em>W</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.binarize" title="Permalink to this definition">¶</a></dt>
<dd><p>Binarizes an input weighted connection matrix.  If copy is not set, this
function will <em>modify W in place.</em></p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted connectivity matrix</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</dd>
</dl>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary connectivity matrix</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.breadth">
<tt class="descclassname">bct.</tt><tt class="descname">breadth</tt><big>(</big><em>CIJ</em>, <em>source</em><big>)</big><a class="headerlink" href="#bct.breadth" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of breadth-first search.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed/undirected connection matrix</dd>
<dt>source <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>source vertex</dd>
</dl>
<dl class="docutils">
<dt>distance <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>vector of distances between source and ith vertex (0 for source)</dd>
<dt>branch <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>vertex that precedes i in the breadth-first search (-1 for source)</dd>
</dl>
<p>Notes: Breadth-first search tree does not contain all paths (or all 
shortest paths), but allows the determination of at least one path with
minimum distance. The entire graph is explored, starting from source 
vertex &#8216;source&#8217;.</p>
</dd></dl>

<dl class="function">
<dt id="bct.breadthdist">
<tt class="descclassname">bct.</tt><tt class="descname">breadthdist</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.breadthdist" title="Permalink to this definition">¶</a></dt>
<dd><p>The binary reachability matrix describes reachability between all pairs
of nodes. An entry (u,v)=1 means that there exists a path from node u
to node v; alternatively (u,v)=0.</p>
<p>The distance matrix contains lengths of shortest paths between all
pairs of nodes. An entry (u,v) represents the length of shortest path 
from node u to  node v. The average shortest path length is the 
characteristic path length of the network.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed/undirected connection matrix</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary reachability matrix</dd>
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray </span></dt>
<dd>distance matrix</dd>
</dl>
<p>Note: slower but less memory intensive than &#8220;reachdist.m&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="bct.charpath">
<tt class="descclassname">bct.</tt><tt class="descname">charpath</tt><big>(</big><em>D</em>, <em>include_diagonal=False</em><big>)</big><a class="headerlink" href="#bct.charpath" title="Permalink to this definition">¶</a></dt>
<dd><p>The characteristic path length is the average shortest path length in 
the network. The global efficiency is the average inverse shortest path
length in the network.</p>
<dl class="docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>distance matrix</dd>
<dt>include_diagonal <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, include the weights on the diagonal. Default value is False.</dd>
</dl>
<dl class="docutils">
<dt>lambda <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>characteristic path length</dd>
<dt>efficiency <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>global efficiency</dd>
<dt>ecc <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>eccentricity at each vertex</dd>
<dt>radius <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>radius of graph</dd>
<dt>diameter <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>diameter of graph</dd>
</dl>
<p>Notes:
The input distance matrix may be obtained with any of the distance
functions, e.g. distance_bin, distance_wei.
Characteristic path length is calculated as the global mean of 
the distance matrix D, excludings any &#8216;Infs&#8217; but including distances on
the main diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="bct.ci2ls">
<tt class="descclassname">bct.</tt><tt class="descname">ci2ls</tt><big>(</big><em>ci</em><big>)</big><a class="headerlink" href="#bct.ci2ls" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a community index vector to a 2D python list of modules
The list is a pure python list, not requiring numpy.</p>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>the community index vector</dd>
<dt>zeroindexed <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, ci uses zero-indexing (lowest value is 0). Defaults to False.</dd>
</dl>
<dl class="docutils">
<dt>ls <span class="classifier-delimiter">:</span> <span class="classifier">listof(list)</span></dt>
<dd>pure python list with lowest value zero-indexed 
(regardless of zero-indexing parameter)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.clustering_coef_bd">
<tt class="descclassname">bct.</tt><tt class="descname">clustering_coef_bd</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.clustering_coef_bd" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>The clustering coefficient is the fraction of triangles around a node
(equiv. the fraction of nodes neighbors that are neighbors of each other).</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed connection matrix</dd>
</dl>
<dl class="docutils">
<dt>C <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>clustering coefficient vector</dd>
</dl>
</div></blockquote>
<p>Input:      A,      binary directed connection matrix</p>
<p>Output:     C,      clustering coefficient vector</p>
<blockquote>
<div><p>Methodological note: In directed graphs, 3 nodes generate up to 8 
triangles (2*2*2 edges). The number of existing triangles is the main 
diagonal of S^3/2. The number of all (in or out) neighbour pairs is 
K(K-1)/2. Each neighbour pair may generate two triangles. &#8220;False pairs&#8221; 
are i&lt;-&gt;j edge pairs (these do not generate triangles). The number of 
false pairs is the main diagonal of A^2.
Thus the maximum possible number of triangles =</p>
<blockquote>
<div>= (2 edges)*([ALL PAIRS] - [FALSE PAIRS])
= 2 * (K(K-1)/2 - diag(A^2))
= K(K-1) - 2(diag(A^2))</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="bct.clustering_coef_bu">
<tt class="descclassname">bct.</tt><tt class="descname">clustering_coef_bu</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.clustering_coef_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>The clustering coefficient is the fraction of triangles around a node
(equiv. the fraction of nodes neighbors that are neighbors of each other).</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary undirected connection matrix</dd>
</dl>
<dl class="docutils">
<dt>C <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>clustering coefficient vector</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.clustering_coef_wd">
<tt class="descclassname">bct.</tt><tt class="descname">clustering_coef_wd</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.clustering_coef_wd" title="Permalink to this definition">¶</a></dt>
<dd><p>The weighted clustering coefficient is the average &#8220;intensity&#8221; of 
triangles around a node.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted directed connection matrix</dd>
</dl>
<dl class="docutils">
<dt>C <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>clustering coefficient vector</dd>
</dl>
<p>Methodological note (also see clustering_coef_bd)
The weighted modification is as follows:
- The numerator: adjacency matrix is replaced with weights matrix ^ 1/3
- The denominator: no changes from the binary version</p>
<p>The above reduces to symmetric and/or binary versions of the clustering 
coefficient for respective graphs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.clustering_coef_wu">
<tt class="descclassname">bct.</tt><tt class="descname">clustering_coef_wu</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.clustering_coef_wu" title="Permalink to this definition">¶</a></dt>
<dd><p>The weighted clustering coefficient is the average &#8220;intensity&#8221; of 
triangles around a node.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted undirected connection matrix</dd>
</dl>
<dl class="docutils">
<dt>C <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>clustering coefficient vector</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.community_louvain">
<tt class="descclassname">bct.</tt><tt class="descname">community_louvain</tt><big>(</big><em>W</em>, <em>gamma=1</em>, <em>ci=None</em>, <em>B='modularity'</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.community_louvain" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes which maximizes the number of within-group
edges and minimizes the number of between-group edges.</p>
<p>This function is a fast an accurate multi-iterative generalization of the
louvain community detection algorithm. This function subsumes and improves
upon modularity_[louvain,finetune]_[und,dir]() and additionally allows to
optimize other objective functions (includes built-in Potts Model i
Hamiltonian, allows for custom objective-function matrices).</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.array</span></dt>
<dd>directed/undirected weighted/binary adjacency matrix</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.
ignored if an objective function matrix is specified.</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.arraylike</span></dt>
<dd>initial community affiliation vector. default value=None</dd>
<dt>B <span class="classifier-delimiter">:</span> <span class="classifier">str | NxN np.arraylike</span></dt>
<dd>string describing objective function type, or provides a custom
objective-function matrix. builtin values &#8216;modularity&#8217; uses Q-metric
as objective function, or &#8216;potts&#8217; uses Potts model Hamiltonian.
Default value &#8216;modularity&#8217;.</dd>
<dt>seed <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>random seed. default value=None. if None, seeds from /dev/urandom.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.array</span></dt>
<dd>final community structure</dd>
<dt>q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>optimized q-statistic (modularity only)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.consensus_und">
<tt class="descclassname">bct.</tt><tt class="descname">consensus_und</tt><big>(</big><em>D</em>, <em>tau</em>, <em>reps=1000</em><big>)</big><a class="headerlink" href="#bct.consensus_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This algorithm seeks a consensus partition of the 
agreement matrix D. The algorithm used here is almost identical to the
one introduced in Lancichinetti &amp; Fortunato (2012): The agreement
matrix D is thresholded at a level TAU to remove an weak elements. The
resulting matrix is then partitions REPS number of times using the
Louvain algorithm (in principle, any clustering algorithm that can
handle weighted matrixes is a suitable alternative to the Louvain
algorithm and can be substituted in its place). This clustering
produces a set of partitions from which a new agreement is built. If
the partitions have not converged to a single representative partition,
the above process repeats itself, starting with the newly built
agreement matrix.</p>
<p>NOTE: In this implementation, the elements of the agreement matrix must
be converted into probabilities.</p>
<p>NOTE: This implementation is slightly different from the original
algorithm proposed by Lanchichinetti &amp; Fortunato. In its original
version, if the thresholding produces singleton communities, those
nodes are reconnected to the network. Here, we leave any singleton
communities disconnected.</p>
<dl class="docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>agreement matrix with entries between 0 and 1 denoting the probability
of finding node i in the same cluster as node j</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>threshold which controls the resolution of the reclustering</dd>
<dt>reps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of times the clustering algorithm is reapplied. default value
is 1000.</dd>
</dl>
<dl class="docutils">
<dt>ciu <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>consensus partition</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.corr_flat_dir">
<tt class="descclassname">bct.</tt><tt class="descname">corr_flat_dir</tt><big>(</big><em>a1</em>, <em>a2</em><big>)</big><a class="headerlink" href="#bct.corr_flat_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the correlation coefficient between two flattened adjacency
matrices.  Similarity metric for weighted matrices.</p>
<dl class="docutils">
<dt>A1 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed matrix 1</dd>
<dt>A2 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed matrix 2</dd>
</dl>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Correlation coefficient describing edgewise similarity of a1 and a2</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.corr_flat_und">
<tt class="descclassname">bct.</tt><tt class="descname">corr_flat_und</tt><big>(</big><em>a1</em>, <em>a2</em><big>)</big><a class="headerlink" href="#bct.corr_flat_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the correlation coefficient between two flattened adjacency
matrices.  Only the upper triangular part is used to avoid double counting
undirected matrices.  Similarity metric for weighted matrices.</p>
<dl class="docutils">
<dt>A1 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected matrix 1</dd>
<dt>A2 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected matrix 2</dd>
</dl>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Correlation coefficient describing edgewise similarity of a1 and a2</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.cycprob">
<tt class="descclassname">bct.</tt><tt class="descname">cycprob</tt><big>(</big><em>Pq</em><big>)</big><a class="headerlink" href="#bct.cycprob" title="Permalink to this definition">¶</a></dt>
<dd><p>Cycles are paths which begin and end at the same node. Cycle 
probability for path length d, is the fraction of all paths of length 
d-1 that may be extended to form cycles of length d.</p>
<dl class="docutils">
<dt>Pq <span class="classifier-delimiter">:</span> <span class="classifier">NxNxQ np.ndarray</span></dt>
<dd>Path matrix with Pq[i,j,q] = number of paths from i to j of length q.
Produced by findpaths()</dd>
</dl>
<dl class="docutils">
<dt>fcyc <span class="classifier-delimiter">:</span> <span class="classifier">Qx1 np.ndarray</span></dt>
<dd>fraction of all paths that are cycles for each path length q</dd>
<dt>pcyc <span class="classifier-delimiter">:</span> <span class="classifier">Qx1 np.ndarray</span></dt>
<dd>probability that a non-cyclic path of length q-1 can be extended to
form a cycle of length q for each path length q</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.degrees_dir">
<tt class="descclassname">bct.</tt><tt class="descname">degrees_dir</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.degrees_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Node degree is the number of links connected to the node. The indegree 
is the number of inward links and the outdegree is the number of 
outward links.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed binary/weighted connection matrix</dd>
</dl>
<dl class="docutils">
<dt>id <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node in-degree</dd>
<dt>od <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node out-degree</dd>
<dt>deg <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node degree (in-degree + out-degree)</dd>
<dt>Notes:  Inputs are assumed to be on the columns of the CIJ matrix.</dt>
<dd>Weight information is discarded.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.degrees_und">
<tt class="descclassname">bct.</tt><tt class="descname">degrees_und</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.degrees_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Node degree is the number of links connected to the node.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected binary/weighted connection matrix</dd>
</dl>
<dl class="docutils">
<dt>deg <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node degree</dd>
</dl>
<p>Note: Weight information is discarded.</p>
</dd></dl>

<dl class="function">
<dt id="bct.density_dir">
<tt class="descclassname">bct.</tt><tt class="descname">density_dir</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.density_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Density is the fraction of present connections to possible connections.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed weighted/binary connection matrix</dd>
</dl>
<dl class="docutils">
<dt>kden <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>density</dd>
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of vertices</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of edges</dd>
<dt>Notes:  Assumes CIJ is directed and has no self-connections.</dt>
<dd>Weight information is discarded.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.density_und">
<tt class="descclassname">bct.</tt><tt class="descname">density_und</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.density_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Density is the fraction of present connections to possible connections.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected (weighted/binary) connection matrix</dd>
</dl>
<dl class="docutils">
<dt>kden <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>density</dd>
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of vertices</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of edges</dd>
<dt>Notes:  Assumes CIJ is undirected and has no self-connections.</dt>
<dd>Weight information is discarded.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.dice_pairwise_und">
<tt class="descclassname">bct.</tt><tt class="descname">dice_pairwise_und</tt><big>(</big><em>a1</em>, <em>a2</em><big>)</big><a class="headerlink" href="#bct.dice_pairwise_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates pairwise dice similarity for each vertex between two 
matrices. Treats the matrices as binary and undirected.</p>
<dl class="docutils">
<dt>A1 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>Matrix 1</dd>
<dt>A2 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>Matrix 2</dd>
</dl>
<dl class="docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>dice similarity vector</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.distance_bin">
<tt class="descclassname">bct.</tt><tt class="descname">distance_bin</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.distance_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>The distance matrix contains lengths of shortest paths between all
pairs of nodes. An entry (u,v) represents the length of shortest path 
from node u to node v. The average shortest path length is the 
characteristic path length of the network.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed/undirected connection matrix</dd>
</dl>
<dl class="docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">NxN </span></dt>
<dd>distance matrix</dd>
<dt>Notes: </dt>
<dd>Lengths between disconnected nodes are set to Inf.
Lengths on the main diagonal are set to 0.</dd>
</dl>
<p>Algorithm: Algebraic shortest paths.</p>
</dd></dl>

<dl class="function">
<dt id="bct.distance_wei">
<tt class="descclassname">bct.</tt><tt class="descname">distance_wei</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.distance_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>The distance matrix contains lengths of shortest paths between all
pairs of nodes. An entry (u,v) represents the length of shortest path 
from node u to node v. The average shortest path length is the 
characteristic path length of the network.</p>
<dl class="docutils">
<dt>L <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>Directed/undirected connection-length matrix.
NB L is not the adjacency matrix. See below.</dd>
</dl>
<dl class="docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>distance (shortest weighted path) matrix</dd>
<dt>B <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>matrix of number of edges in shortest weighted path</dd>
<dt>Notes:</dt>
<dd>The input matrix must be a connection-length matrix, typically</dd>
</dl>
<p>obtained via a mapping from weight to length. For instance, in a
weighted correlation network higher correlations are more naturally
interpreted as shorter distances and the input matrix should
consequently be some inverse of the connectivity matrix.</p>
<blockquote>
<div>The number of edges in shortest weighted paths may in general</div></blockquote>
<p>exceed the number of edges in shortest binary paths (i.e. shortest
paths computed on the binarized connectivity matrix), because shortest 
weighted paths have the minimal weighted distance, but not necessarily 
the minimal number of edges.</p>
<blockquote>
<div>Lengths between disconnected nodes are set to Inf.
Lengths on the main diagonal are set to 0.</div></blockquote>
<p>Algorithm: Dijkstra&#8217;s algorithm.</p>
</dd></dl>

<dl class="function">
<dt id="bct.diversity_coef_sign">
<tt class="descclassname">bct.</tt><tt class="descname">diversity_coef_sign</tt><big>(</big><em>W</em>, <em>ci</em><big>)</big><a class="headerlink" href="#bct.diversity_coef_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>The Shannon-entropy based diversity coefficient measures the diversity
of intermodular connections of individual nodes and ranges from 0 to 1.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected connection matrix with positive and negative weights</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>community affiliation vector</dd>
</dl>
<dl class="docutils">
<dt>Hpos <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>diversity coefficient based on positive connections</dd>
<dt>Hneg <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>diversity coefficient based on negative connections</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.dummyvar">
<tt class="descclassname">bct.</tt><tt class="descname">dummyvar</tt><big>(</big><em>cis</em>, <em>return_sparse=False</em><big>)</big><a class="headerlink" href="#bct.dummyvar" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an efficient implementation of matlab&#8217;s &#8220;dummyvar&#8221; command
using sparse matrices.</p>
<dl class="docutils">
<dt>input: partitions, NxM array-like containing M partitions of N nodes</dt>
<dd>into &lt;=N distinct communities</dd>
<dt>output: dummyvar, an NxR matrix containing R column variables (indicator</dt>
<dd><p class="first">variables) with N entries, where R is the total number of communities
summed across each of the M partitions.</p>
<p class="last">i.e.
r = sum((max(len(unique(partitions[i]))) for i in range(m)))</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.edge_betweenness_bin">
<tt class="descclassname">bct.</tt><tt class="descname">edge_betweenness_bin</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.edge_betweenness_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Edge betweenness centrality is the fraction of all shortest paths in 
the network that contain a given edge. Edges with high values of 
betweenness centrality participate in a large number of shortest paths.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed/undirected connection matrix</dd>
</dl>
<dl class="docutils">
<dt>EBC <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>edge betweenness centrality matrix</dd>
<dt>BC <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node betweenness centrality vector</dd>
</dl>
<p>Note: Betweenness centrality may be normalised to the range [0,1] as
BC/[(N-1)(N-2)], where N is the number of nodes in the network.</p>
</dd></dl>

<dl class="function">
<dt id="bct.edge_betweenness_wei">
<tt class="descclassname">bct.</tt><tt class="descname">edge_betweenness_wei</tt><big>(</big><em>G</em><big>)</big><a class="headerlink" href="#bct.edge_betweenness_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Edge betweenness centrality is the fraction of all shortest paths in 
the network that contain a given edge. Edges with high values of 
betweenness centrality participate in a large number of shortest paths.</p>
<dl class="docutils">
<dt>L <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed/undirected weighted connection matrix</dd>
</dl>
<dl class="docutils">
<dt>EBC <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>edge betweenness centrality matrix</dd>
<dt>BC <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>nodal betweenness centrality vector</dd>
<dt>Notes:</dt>
<dd><dl class="first last docutils">
<dt>The input matrix must be a connection-length matrix, typically</dt>
<dd>obtained via a mapping from weight to length. For instance, in a
weighted correlation network higher correlations are more naturally
interpreted as shorter distances and the input matrix should
consequently be some inverse of the connectivity matrix.</dd>
<dt>Betweenness centrality may be normalised to the range [0,1] as</dt>
<dd>BC/[(N-1)(N-2)], where N is the number of nodes in the network.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.edge_nei_overlap_bd">
<tt class="descclassname">bct.</tt><tt class="descname">edge_nei_overlap_bd</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.edge_nei_overlap_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>This function determines the neighbors of two nodes that are linked by 
an edge, and then computes their overlap.  Connection matrix must be
binary and directed.  Entries of &#8216;EC&#8217; that are &#8216;inf&#8217; indicate that no
edge is present.  Entries of &#8216;EC&#8217; that are 0 denote &#8220;local bridges&#8221;,
i.e. edges that link completely non-overlapping neighborhoods.  Low
values of EC indicate edges that are &#8220;weak ties&#8221;.</p>
<p>If CIJ is weighted, the weights are ignored. Neighbors of a node can be
linked by incoming, outgoing, or reciprocal connections.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed binary/weighted connection matrix</dd>
</dl>
<dl class="docutils">
<dt>EC <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>edge neighborhood overlap matrix</dd>
<dt>ec <span class="classifier-delimiter">:</span> <span class="classifier">Kx1 np.ndarray</span></dt>
<dd>edge neighborhood overlap per edge vector</dd>
<dt>degij <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>degrees of node pairs connected by each edge</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.edge_nei_overlap_bu">
<tt class="descclassname">bct.</tt><tt class="descname">edge_nei_overlap_bu</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.edge_nei_overlap_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function determines the neighbors of two nodes that are linked by 
an edge, and then computes their overlap.  Connection matrix must be
binary and directed.  Entries of &#8216;EC&#8217; that are &#8216;inf&#8217; indicate that no
edge is present.  Entries of &#8216;EC&#8217; that are 0 denote &#8220;local bridges&#8221;, i.e.
edges that link completely non-overlapping neighborhoods.  Low values
of EC indicate edges that are &#8220;weak ties&#8221;.</p>
<p>If CIJ is weighted, the weights are ignored.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected binary/weighted connection matrix</dd>
</dl>
<dl class="docutils">
<dt>EC <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>edge neighborhood overlap matrix</dd>
<dt>ec <span class="classifier-delimiter">:</span> <span class="classifier">Kx1 np.ndarray</span></dt>
<dd>edge neighborhood overlap per edge vector</dd>
<dt>degij <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>degrees of node pairs connected by each edge</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.efficiency_bin">
<tt class="descclassname">bct.</tt><tt class="descname">efficiency_bin</tt><big>(</big><em>G</em>, <em>local=False</em><big>)</big><a class="headerlink" href="#bct.efficiency_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>The global efficiency is the average of inverse shortest path length, 
and is inversely related to the characteristic path length.</p>
<p>The local efficiency is the global efficiency computed on the
neighborhood of the node, and is related to the clustering coefficient.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary undirected connection matrix</dd>
<dt>local <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, computes local efficiency instead of global efficiency.
Default value = False.</dd>
</dl>
<dl class="docutils">
<dt>Eglob <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>global efficiency, only if local=False</dd>
<dt>Eloc <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>local efficiency, only if local=True</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.efficiency_wei">
<tt class="descclassname">bct.</tt><tt class="descname">efficiency_wei</tt><big>(</big><em>Gw</em>, <em>local=False</em><big>)</big><a class="headerlink" href="#bct.efficiency_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>The global efficiency is the average of inverse shortest path length, 
and is inversely related to the characteristic path length.</p>
<p>The local efficiency is the global efficiency computed on the
neighborhood of the node, and is related to the clustering coefficient.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected weighted connection matrix
(all weights in W must be between 0 and 1)</dd>
<dt>local <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, computes local efficiency instead of global efficiency.
Default value = False.</dd>
</dl>
<dl class="docutils">
<dt>Eglob <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>global efficiency, only if local=False</dd>
<dt>Eloc <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>local efficiency, only if local=True</dd>
<dt>Notes:</dt>
<dd>The  efficiency is computed using an auxiliary connection-length</dd>
</dl>
<p>matrix L, defined as L_ij = 1/W_ij for all nonzero L_ij; This has an
intuitive interpretation, as higher connection weights intuitively
correspond to shorter lengths.</p>
<blockquote>
<div>The weighted local efficiency broadly parallels the weighted</div></blockquote>
<p>clustering coefficient of Onnela et al. (2005) and distinguishes the
influence of different paths based on connection weights of the
corresponding neighbors to the node in question. In other words, a path
between two neighbors with strong connections to the node in question
contributes more to the local efficiency than a path between two weakly
connected neighbors. Note that this weighted variant of the local
efficiency is hence not a strict generalization of the binary variant.</p>
<p>Algorithm:  Dijkstra&#8217;s algorithm</p>
</dd></dl>

<dl class="function">
<dt id="bct.eigenvector_centrality_und">
<tt class="descclassname">bct.</tt><tt class="descname">eigenvector_centrality_und</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.eigenvector_centrality_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenector centrality is a self-referential measure of centrality:
nodes have high eigenvector centrality if they connect to other nodes
that have high eigenvector centrality. The eigenvector centrality of
node i is equivalent to the ith element in the eigenvector 
corresponding to the largest eigenvalue of the adjacency matrix.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary/weighted undirected adjacency matrix</dd>
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>eigenvector associated with the largest eigenvalue of the matrix</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.erange">
<tt class="descclassname">bct.</tt><tt class="descname">erange</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.erange" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcuts are central edges which significantly reduce the
characteristic path length in the network.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed connection matrix</dd>
</dl>
<dl class="docutils">
<dt>Erange <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>range for each edge, i.e. the length of the shortest path from i to j
for edge c(i,j) after the edge has been removed from the graph</dd>
<dt>eta <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>average range for the entire graph</dd>
<dt>Eshort <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>entries are ones for shortcut edges</dd>
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>fractions of shortcuts in the graph</dd>
</dl>
<p>Follows the treatment of &#8216;shortcuts&#8217; by Duncan Watts</p>
</dd></dl>

<dl class="function">
<dt id="bct.find_motif34">
<tt class="descclassname">bct.</tt><tt class="descname">find_motif34</tt><big>(</big><em>m</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#bct.find_motif34" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns all motif isomorphs for a given motif id and 
class (3 or 4). The function also returns the motif id for a given
motif matrix</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>Input:       Motif_id,           e.g. 1 to 13, if class is 3</dt>
<dd><p class="first last">Motif_class,        number of nodes, 3 or 4.</p>
</dd>
</dl>
</li>
</ol>
<p>Output:      Motif_matrices,     all isomorphs for the given motif</p>
<p>2. Input:       Motif_matrix        e.g. [0 1 0; 0 0 1; 1 0 0]
Output       Motif_id            e.g. 1 to 13, if class is 3</p>
<dl class="docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">int | matrix</span></dt>
<dd>In use case 1, a motif_id which is an integer.
In use case 2, the entire matrix of the motif 
(e.g. [0 1 0; 0 0 1; 1 0 0])</dd>
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>In use case 1, the motif class, which is the number of nodes. This is
either 3 or 4.
In use case 2, None.</dd>
</dl>
<dl class="docutils">
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray | int</span></dt>
<dd>In use case 1, returns all isomorphs for the given motif
In use case 2, returns the motif_id for the specified motif matrix</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.findpaths">
<tt class="descclassname">bct.</tt><tt class="descname">findpaths</tt><big>(</big><em>CIJ</em>, <em>qmax</em>, <em>sources</em>, <em>savepths=False</em><big>)</big><a class="headerlink" href="#bct.findpaths" title="Permalink to this definition">¶</a></dt>
<dd><p>Paths are sequences of linked nodes, that never visit a single node
more than once. This function finds all paths that start at a set of 
source nodes, up to a specified length. Warning: very memory-intensive.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed/undirected connection matrix</dd>
<dt>qmax <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>maximal path length</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>source units from which paths are grown</dd>
<dt>savepths <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>True if all paths are to be collected and returned. This functionality
is currently not enabled.</dd>
</dl>
<dl class="docutils">
<dt>Pq <span class="classifier-delimiter">:</span> <span class="classifier">NxNxQ np.ndarray</span></dt>
<dd>Path matrix with P[i,j,jq] = number of paths from i to j with length q</dd>
<dt>tpath <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>total number of paths found</dd>
<dt>plq <span class="classifier-delimiter">:</span> <span class="classifier">Qx1 np.ndarray</span></dt>
<dd>path length distribution as a function of q</dd>
<dt>qstop <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>path length at which findpaths is stopped</dd>
<dt>allpths <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd>a matrix containing all paths up to qmax. This function is extremely
complicated and reimplementing it in bctpy is not straightforward.</dd>
<dt>util <span class="classifier-delimiter">:</span> <span class="classifier">NxQ np.ndarray</span></dt>
<dd>node use index</dd>
</dl>
<p>Note that Pq(:,:,N) can only carry entries on the diagonal, as all
&#8220;legal&#8221; paths of length N-1 must terminate.  Cycles of length N are
possible, with all vertices visited exactly once (except for source and
target). &#8216;qmax = N&#8217; can wreak havoc (due to memory problems).</p>
<p>Note: Weights are discarded.
Note: I am certain that this algorithm is rather inefficient -
suggestions for improvements are welcome.</p>
</dd></dl>

<dl class="function">
<dt id="bct.findwalks">
<tt class="descclassname">bct.</tt><tt class="descname">findwalks</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.findwalks" title="Permalink to this definition">¶</a></dt>
<dd><p>Walks are sequences of linked nodes, that may visit a single node more
than once. This function finds the number of walks of a given length, 
between any two nodes.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed/undirected connection matrix</dd>
</dl>
<dl class="docutils">
<dt>Wq <span class="classifier-delimiter">:</span> <span class="classifier">NxNxQ np.ndarray</span></dt>
<dd>Wq[i,j,q] is the number of walks from i to j of length q</dd>
<dt>twalk <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>total number of walks found</dd>
<dt>wlq <span class="classifier-delimiter">:</span> <span class="classifier">Qx1 np.ndarray</span></dt>
<dd>walk length distribution as a function of q</dd>
</dl>
<p>Notes: Wq grows very quickly for larger N,K,q. Weights are discarded.</p>
</dd></dl>

<dl class="function">
<dt id="bct.flow_coef_bd">
<tt class="descclassname">bct.</tt><tt class="descname">flow_coef_bd</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.flow_coef_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the flow coefficient for each node and averaged over the
network, as described in Honey et al. (2007) PNAS. The flow coefficient
is similar to betweenness centrality, but works on a local
neighborhood. It is mathematically related to the clustering
coefficient  (cc) at each node as, fc+cc &lt;= 1.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed connection matrix</dd>
</dl>
<dl class="docutils">
<dt>fc <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>flow coefficient for each node</dd>
<dt>FC <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>average flow coefficient over the network</dd>
<dt>total_flo <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of paths that &#8220;flow&#8221; across the central node</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.get_components">
<tt class="descclassname">bct.</tt><tt class="descname">get_components</tt><big>(</big><em>A</em>, <em>no_depend=False</em><big>)</big><a class="headerlink" href="#bct.get_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the components of an undirected graph specified by the binary and 
undirected adjacency matrix adj. Components and their constitutent nodes 
are assigned the same index and stored in the vector, comps. The vector, 
comp_sizes, contains the number of nodes beloning to each component.</p>
<dl class="docutils">
<dt>adj <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary undirected adjacency matrix</dd>
<dt>no_depend <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If true, doesn&#8217;t import networkx to do the calculation. Default value
is false.</dd>
</dl>
<dl class="docutils">
<dt>comps <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>vector of component assignments for each node</dd>
<dt>comp_sizes <span class="classifier-delimiter">:</span> <span class="classifier">Mx1 np.ndarray</span></dt>
<dd>vector of component sizes</dd>
</dl>
<p>Note: disconnected nodes will appear as components with a component
size of 1</p>
<p>Note: The identity of each component (i.e. its numerical value in the 
result) is not guaranteed to be identical the value returned in BCT, 
although the component topology is.</p>
<p>Note: networkx is used to do the computation efficiently. If networkx is 
not available a breadth-first search that does not depend on networkx is 
used instead, but this is less efficient. The corresponding BCT function 
does the computation by computing the Dulmage-Mendelsohn decomposition. I 
don&#8217;t know what a Dulmage-Mendelsohn decomposition is and there doesn&#8217;t 
appear to be a python equivalent. If you think of a way to implement this 
better, let me know.</p>
</dd></dl>

<dl class="function">
<dt id="bct.grid_communities">
<tt class="descclassname">bct.</tt><tt class="descname">grid_communities</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#bct.grid_communities" title="Permalink to this definition">¶</a></dt>
<dd><p>(X,Y,INDSORT) = GRID_COMMUNITIES(C) takes a vector of community
assignments C and returns three output arguments for visualizing the
communities. The third is INDSORT, which is an ordering of the vertices
so that nodes with the same community assignment are next to one
another. The first two arguments are vectors that, when overlaid on the
adjacency matrix using the PLOT function, highlight the communities.</p>
<dl class="docutils">
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>community assignments</dd>
</dl>
<dl class="docutils">
<dt>bounds <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list containing the communities</dd>
<dt>indsort <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>indices</dd>
</dl>
<p>Note: This function returns considerably different values than in
matlab due to differences between matplotlib and matlab.  This function
has been designed to work with matplotlib, as in the following example:</p>
<p>ci,_=modularity_und(adj)
bounds,ixes=grid_communities(ci)
pylab.imshow(adj[np.ix_(ixes,ixes)],interpolation=&#8217;none&#8217;,cmap=&#8217;BuGn&#8217;)       
for b in bounds:</p>
<blockquote>
<div>pylab.axvline(x=b,color=&#8217;red&#8217;)
pylab.axhline(y=b,color=&#8217;red&#8217;)</div></blockquote>
<p>Note that I adapted the idea from the matlab function of the same name,
and have not tested the functionality extensively.</p>
</dd></dl>

<dl class="function">
<dt id="bct.gtom">
<tt class="descclassname">bct.</tt><tt class="descname">gtom</tt><big>(</big><em>adj</em>, <em>nr_steps</em><big>)</big><a class="headerlink" href="#bct.gtom" title="Permalink to this definition">¶</a></dt>
<dd><p>The m-th step generalized topological overlap measure (GTOM) quantifies
the extent to which a pair of nodes have similar m-th step neighbors.
Mth-step neighbors are nodes that are reachable by a path of at most
length m.</p>
<p>This function computes the the M x M generalized topological overlap
measure (GTOM) matrix for number of steps, numSteps.</p>
<dl class="docutils">
<dt>adj <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix</dd>
<dt>nr_steps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of steps</dd>
</dl>
<dl class="docutils">
<dt>gt <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>GTOM matrix</dd>
</dl>
<p>NOTE: When numSteps is equal to 1, GTOM is identical to the topological
overlap measure (TOM) from reference [2]. In that case the &#8216;gt&#8217; matrix
records, for each pair of nodes, the fraction of neighbors the two
nodes share in common, where &#8220;neighbors&#8221; are one step removed. As
&#8216;numSteps&#8217; is increased, neighbors that are furter out are considered.
Elements of &#8216;gt&#8217; are bounded between 0 and 1.  The &#8216;gt&#8217; matrix can be
converted from a similarity to a distance matrix by taking 1-gt.</p>
</dd></dl>

<dl class="function">
<dt id="bct.invert">
<tt class="descclassname">bct.</tt><tt class="descname">invert</tt><big>(</big><em>W</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverts elementwise the weights in an input connection matrix. 
In other words, change the from the matrix of internode strengths to the 
matrix of internode distances.</p>
<p>If copy is not set, this function will <em>modify W in place.</em></p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>weighted connectivity matrix</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</dd>
</dl>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>inverted connectivity matrix</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.jdegree">
<tt class="descclassname">bct.</tt><tt class="descname">jdegree</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.jdegree" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a matrix in which the value of each element (u,v)
corresponds to the number of nodes that have u outgoing connections 
and v incoming connections.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed binary/weighted connnection matrix</dd>
</dl>
<dl class="docutils">
<dt>J <span class="classifier-delimiter">:</span> <span class="classifier">ZxZ np.ndarray</span></dt>
<dd>joint degree distribution matrix
(shifted by one, replicates matlab one-based-indexing)</dd>
<dt>J_od <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of vertices with od&gt;id</dd>
<dt>J_id <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of vertices with id&gt;od</dd>
<dt>J_bl <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of vertices with id==od</dd>
</dl>
<p>Note: Weights are discarded.</p>
</dd></dl>

<dl class="function">
<dt id="bct.kcore_bd">
<tt class="descclassname">bct.</tt><tt class="descname">kcore_bd</tt><big>(</big><em>CIJ</em>, <em>k</em>, <em>peel=False</em><big>)</big><a class="headerlink" href="#bct.kcore_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>The k-core is the largest subnetwork comprising nodes of degree at
least k. This function computes the k-core for a given binary directed
connection matrix by recursively peeling off nodes with degree lower
than k, until no such nodes remain.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed adjacency matrix</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>level of k-core</dd>
<dt>peel <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, additionally calculates peelorder and peellevel. Defaults to
False.</dd>
</dl>
<dl class="docutils">
<dt>CIJkcore <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix of the k-core. This matrix only contains nodes of
degree at least k.</dd>
<dt>kn <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>size of k-core</dd>
<dt>peelorder <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>indices in the order in which they were peeled away during k-core
decomposition. only returned if peel is specified.</dd>
<dt>peellevel <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>corresponding level - nodes in at the same level have been peeled
away at the same time. only return if peel is specified</dd>
</dl>
<p>&#8216;peelorder&#8217; and &#8216;peellevel&#8217; are similar the the k-core sub-shells
described in Modha and Singh (2010).</p>
</dd></dl>

<dl class="function">
<dt id="bct.kcore_bu">
<tt class="descclassname">bct.</tt><tt class="descname">kcore_bu</tt><big>(</big><em>CIJ</em>, <em>k</em>, <em>peel=False</em><big>)</big><a class="headerlink" href="#bct.kcore_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>The k-core is the largest subnetwork comprising nodes of degree at
least k. This function computes the k-core for a given binary
undirected connection matrix by recursively peeling off nodes with
degree lower than k, until no such nodes remain.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary undirected connection matrix</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>level of k-core</dd>
<dt>peel <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, additionally calculates peelorder and peellevel. Defaults to
False.</dd>
</dl>
<dl class="docutils">
<dt>CIJkcore <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix of the k-core. This matrix only contains nodes of
degree at least k.</dd>
<dt>kn <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>size of k-core</dd>
<dt>peelorder <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>indices in the order in which they were peeled away during k-core
decomposition. only returned if peel is specified.</dd>
<dt>peellevel <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>corresponding level - nodes in at the same level have been peeled
away at the same time. only return if peel is specified</dd>
</dl>
<p>&#8216;peelorder&#8217; and &#8216;peellevel&#8217; are similar the the k-core sub-shells
described in Modha and Singh (2010).</p>
</dd></dl>

<dl class="function">
<dt id="bct.kcoreness_centrality_bd">
<tt class="descclassname">bct.</tt><tt class="descname">kcoreness_centrality_bd</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.kcoreness_centrality_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>The k-core is the largest subgraph comprising nodes of degree at least
k. The coreness of a node is k if the node belongs to the k-core but
not to the (k+1)-core. This function computes k-coreness of all nodes
for a given binary directed connection matrix.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed connection matrix</dd>
</dl>
<dl class="docutils">
<dt>coreness <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node coreness</dd>
<dt>kn <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>size of k-core</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.kcoreness_centrality_bu">
<tt class="descclassname">bct.</tt><tt class="descname">kcoreness_centrality_bu</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.kcoreness_centrality_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>The k-core is the largest subgraph comprising nodes of degree at least
k. The coreness of a node is k if the node belongs to the k-core but
not to the (k+1)-core. This function computes the coreness of all nodes
for a given binary undirected connection matrix.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary undirected connection matrix</dd>
</dl>
<dl class="docutils">
<dt>coreness <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node coreness</dd>
<dt>kn <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>size of k-core</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.latmio_dir">
<tt class="descclassname">bct.</tt><tt class="descname">latmio_dir</tt><big>(</big><em>R</em>, <em>iter</em>, <em>D=None</em><big>)</big><a class="headerlink" href="#bct.latmio_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>This function &#8220;latticizes&#8221; a directed network, while preserving the in-
and out-degree distributions. In weighted networks, the function
preserves the out-strength but not the in-strength distributions.</p>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed binary/weighted connection matrix</dd>
<dt>iter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>rewiring parameter. Each edge is rewired approximately iter times.</dd>
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray | None</span></dt>
<dd>distance-to-diagonal matrix. Defaults to the actual distance matrix
if not specified.</dd>
</dl>
<dl class="docutils">
<dt>Rlatt <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>latticized network in original node ordering</dd>
<dt>Rrp <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>latticized network in node ordering used for latticization</dd>
<dt>ind_rp <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node ordering used for latticization</dd>
<dt>eff <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of actual rewirings carried out</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.latmio_dir_connected">
<tt class="descclassname">bct.</tt><tt class="descname">latmio_dir_connected</tt><big>(</big><em>R</em>, <em>iter</em>, <em>D=None</em><big>)</big><a class="headerlink" href="#bct.latmio_dir_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>This function &#8220;latticizes&#8221; a directed network, while preserving the in-
and out-degree distributions. In weighted networks, the function
preserves the out-strength but not the in-strength distributions. The 
function also ensures that the randomized network maintains
connectedness, the ability for every node to reach every other node in
the network. The input network for this function must be connected.</p>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed binary/weighted connection matrix</dd>
<dt>iter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>rewiring parameter. Each edge is rewired approximately iter times.</dd>
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray | None</span></dt>
<dd>distance-to-diagonal matrix. Defaults to the actual distance matrix
if not specified.</dd>
</dl>
<dl class="docutils">
<dt>Rlatt <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>latticized network in original node ordering</dd>
<dt>Rrp <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>latticized network in node ordering used for latticization</dd>
<dt>ind_rp <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node ordering used for latticization</dd>
<dt>eff <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of actual rewirings carried out</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.latmio_und">
<tt class="descclassname">bct.</tt><tt class="descname">latmio_und</tt><big>(</big><em>R</em>, <em>iter</em>, <em>D=None</em><big>)</big><a class="headerlink" href="#bct.latmio_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This function &#8220;latticizes&#8221; an undirected network, while preserving the 
degree distribution. The function does not preserve the strength 
distribution in weighted networks.</p>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected binary/weighted connection matrix</dd>
<dt>iter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>rewiring parameter. Each edge is rewired approximately iter times.</dd>
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray | None</span></dt>
<dd>distance-to-diagonal matrix. Defaults to the actual distance matrix
if not specified.</dd>
</dl>
<dl class="docutils">
<dt>Rlatt <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>latticized network in original node ordering</dd>
<dt>Rrp <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>latticized network in node ordering used for latticization</dd>
<dt>ind_rp <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node ordering used for latticization</dd>
<dt>eff <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of actual rewirings carried out</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.latmio_und_connected">
<tt class="descclassname">bct.</tt><tt class="descname">latmio_und_connected</tt><big>(</big><em>R</em>, <em>iter</em>, <em>D=None</em><big>)</big><a class="headerlink" href="#bct.latmio_und_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>This function &#8220;latticizes&#8221; an undirected network, while preserving the 
degree distribution. The function does not preserve the strength 
distribution in weighted networks. The function also ensures that the 
randomized network maintains connectedness, the ability for every node 
to reach every other node in the network. The input network for this 
function must be connected.</p>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected binary/weighted connection matrix</dd>
<dt>iter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>rewiring parameter. Each edge is rewired approximately iter times.</dd>
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray | None</span></dt>
<dd>distance-to-diagonal matrix. Defaults to the actual distance matrix
if not specified.</dd>
</dl>
<dl class="docutils">
<dt>Rlatt <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>latticized network in original node ordering</dd>
<dt>Rrp <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>latticized network in node ordering used for latticization</dd>
<dt>ind_rp <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node ordering used for latticization</dd>
<dt>eff <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of actual rewirings carried out</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.link_communities">
<tt class="descclassname">bct.</tt><tt class="descname">link_communities</tt><big>(</big><em>W</em>, <em>type_clustering='single'</em><big>)</big><a class="headerlink" href="#bct.link_communities" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes which maximizes the number of within-group
edges and minimizes the number of between-group edges.</p>
<p>This algorithm uncovers overlapping community structure via hierarchical
clustering of network links. This algorithm is generalized for
weighted/directed/fully-connected networks</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.array</span></dt>
<dd>directed weighted/binary adjacency matrix</dd>
<dt>type_clustering <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>type of hierarchical clustering. &#8216;single&#8217; for single-linkage,
&#8216;complete&#8217; for complete-linkage. Default value=&#8217;single&#8217;</dd>
</dl>
<dl class="docutils">
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">CxN np.ndarray</span></dt>
<dd>nodal community affiliation matrix.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.ls2ci">
<tt class="descclassname">bct.</tt><tt class="descname">ls2ci</tt><big>(</big><em>ls</em>, <em>zeroindexed=False</em><big>)</big><a class="headerlink" href="#bct.ls2ci" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a 2D python list of modules to a community index vector.
The list is a pure python list, not requiring numpy.</p>
<dl class="docutils">
<dt>ls <span class="classifier-delimiter">:</span> <span class="classifier">listof(list)</span></dt>
<dd>pure python list with lowest value zero-indexed
(regardless of value of zeroindexed parameter)</dd>
<dt>zeroindexed <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, ci uses zero-indexing (lowest value is 0). Defaults to False.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>community index vector</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.make_motif34lib">
<tt class="descclassname">bct.</tt><tt class="descname">make_motif34lib</tt><big>(</big><big>)</big><a class="headerlink" href="#bct.make_motif34lib" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates the motif34lib.mat library required for all
other motif computations. Not to be called externally.</p>
</dd></dl>

<dl class="function">
<dt id="bct.makeevenCIJ">
<tt class="descclassname">bct.</tt><tt class="descname">makeevenCIJ</tt><big>(</big><em>n</em>, <em>k</em>, <em>sz_cl</em><big>)</big><a class="headerlink" href="#bct.makeevenCIJ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a random, directed network with a specified 
number of fully connected modules linked together by evenly distributed
remaining random connections.</p>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of vertices (must be power of 2)</dd>
<dt>K <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of edges</dd>
<dt>sz_cl <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>size of clusters (must be power of 2)</dd>
</dl>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix</dd>
<dt>Notes:  N must be a power of 2.</dt>
<dd>A warning is generated if all modules contain more edges than K.
Cluster size is 2^sz_cl;</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.makefractalCIJ">
<tt class="descclassname">bct.</tt><tt class="descname">makefractalCIJ</tt><big>(</big><em>mx_lvl</em>, <em>E</em>, <em>sz_cl</em><big>)</big><a class="headerlink" href="#bct.makefractalCIJ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a directed network with a hierarchical modular
organization. All modules are fully connected and connection density 
decays as 1/(E^n), with n = index of hierarchical level.</p>
<dl class="docutils">
<dt>mx_lvl <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of hierarchical levels, N = 2^mx_lvl</dd>
<dt>E <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>connection density fall off per level</dd>
<dt>sz_cl <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>size of clusters (must be power of 2)</dd>
</dl>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix</dd>
<dt>K <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of connections present in output CIJ</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.makerandCIJ_dir">
<tt class="descclassname">bct.</tt><tt class="descname">makerandCIJ_dir</tt><big>(</big><em>n</em>, <em>k</em><big>)</big><a class="headerlink" href="#bct.makerandCIJ_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a directed random network</p>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of vertices</dd>
<dt>K <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of edges</dd>
</dl>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed random connection matrix</dd>
</dl>
<p>Note: no connections are placed on the main diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="bct.makerandCIJ_und">
<tt class="descclassname">bct.</tt><tt class="descname">makerandCIJ_und</tt><big>(</big><em>n</em>, <em>k</em><big>)</big><a class="headerlink" href="#bct.makerandCIJ_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates an undirected random network</p>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of vertices</dd>
<dt>K <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of edges</dd>
</dl>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected random connection matrix</dd>
</dl>
<p>Note: no connections are placed on the main diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="bct.makerandCIJdegreesfixed">
<tt class="descclassname">bct.</tt><tt class="descname">makerandCIJdegreesfixed</tt><big>(</big><em>inv</em>, <em>outv</em><big>)</big><a class="headerlink" href="#bct.makerandCIJdegreesfixed" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a directed random network with a specified 
in-degree and out-degree sequence.</p>
<dl class="docutils">
<dt>inv <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>in-degree vector</dd>
<dt>outv <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>out-degree vector</dd>
</dl>
<p>CIJ : NxN np.ndarray</p>
<dl class="docutils">
<dt>Notes:  Necessary conditions include:</dt>
<dd><blockquote class="first">
<div>length(in) = length(out) = n
sum(in) = sum(out) = k
in(i), out(i) &lt; n-1
in(i) + out(j) &lt; n+2
in(i) + out(i) &lt; n</div></blockquote>
<p>No connections are placed on the main diagonal</p>
<p class="last">The algorithm used in this function is not, technically, guaranteed to
terminate. If a valid distribution of in and out degrees is provided, 
this function will find it in bounded time with probability 
1-(1/(2*(k^2))). This turns out to be a serious problem when 
computing infinite degree matrices, but offers good performance 
otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.makeringlatticeCIJ">
<tt class="descclassname">bct.</tt><tt class="descname">makeringlatticeCIJ</tt><big>(</big><em>n</em>, <em>k</em><big>)</big><a class="headerlink" href="#bct.makeringlatticeCIJ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a directed lattice network with toroidal 
boundary counditions (i.e. with ring-like &#8220;wrapping around&#8221;).</p>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of vertices</dd>
<dt>K <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of edges</dd>
</dl>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix</dd>
</dl>
<p>Note: The lattice is made by placing connections as close as possible 
to the main diagonal, with wrapping around. No connections are made 
on the main diagonal. In/Outdegree is kept approx. constant at K/N.</p>
</dd></dl>

<dl class="function">
<dt id="bct.maketoeplitzCIJ">
<tt class="descclassname">bct.</tt><tt class="descname">maketoeplitzCIJ</tt><big>(</big><em>n</em>, <em>k</em>, <em>s</em><big>)</big><a class="headerlink" href="#bct.maketoeplitzCIJ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function generates a directed network with a Gaussian drop-off in
edge density with increasing distance from the main diagonal. There are
toroidal boundary counditions (i.e. no ring-like &#8220;wrapping around&#8221;).</p>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of vertices</dd>
<dt>K <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of edges</dd>
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>standard deviation of toeplitz</dd>
</dl>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix</dd>
</dl>
<p>Note: no connections are placed on the main diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="bct.matching_ind">
<tt class="descclassname">bct.</tt><tt class="descname">matching_ind</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.matching_ind" title="Permalink to this definition">¶</a></dt>
<dd><p>For any two nodes u and v, the matching index computes the amount of
overlap in the connection patterns of u and v. Self-connections and
u-v connections are ignored. The matching index is a symmetric 
quantity, similar to a correlation or a dot product.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>adjacency matrix</dd>
</dl>
<dl class="docutils">
<dt>Min <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>matching index for incoming connections</dd>
<dt>Mout <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>matching index for outgoing connections</dd>
<dt>Mall <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>matching index for all connections</dd>
<dt>Notes:</dt>
<dd>Does not use self- or cross connections for comparison.
Does not use connections that are not present in BOTH u and v.
All output matrices are calculated for upper triangular only.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.matching_ind_und">
<tt class="descclassname">bct.</tt><tt class="descname">matching_ind_und</tt><big>(</big><em>CIJ0</em><big>)</big><a class="headerlink" href="#bct.matching_ind_und" title="Permalink to this definition">¶</a></dt>
<dd><p>M0 = MATCHING_IND_UND(CIJ) computes matching index for undirected
graph specified by adjacency matrix CIJ. Matching index is a measure of
similarity between two nodes&#8217; connectivity profiles (excluding their
mutual connection, should it exist).</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected adjacency matrix</dd>
</dl>
<dl class="docutils">
<dt>M0 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>matching index matrix</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_dir">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_dir</tt><big>(</big><em>A</em>, <em>gamma=1</em>, <em>kci=None</em><big>)</big><a class="headerlink" href="#bct.modularity_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges. 
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed weighted/binary connection matrix</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</dd>
<dt>kci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray | None</span></dt>
<dd>starting community structure. If specified, calculates the Q-metric
on the community structure giving, without doing any optimzation.
Otherwise, if not specified, uses a spectral modularity maximization
algorithm.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>optimized community structure</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>maximized modularity metric</dd>
</dl>
<p>Note: This algorithm is deterministic. The matlab function bearing this 
name incorrectly disclaims that the outcome depends on heuristics 
involving a random seed. The louvain method does depend on a random seed, 
but this function uses a deterministic modularity maximization algorithm.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_finetune_dir">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_finetune_dir</tt><big>(</big><em>W</em>, <em>ci=None</em>, <em>gamma=1</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_finetune_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>This algorithm is inspired by the Kernighan-Lin fine-tuning algorithm
and is designed to refine a previously detected community structure.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed weighted/binary connection matrix</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray | None</span></dt>
<dd>initial community affiliation vector</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</dd>
<dt>seed <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>random seed. default value=None. if None, seeds from /dev/urandom.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>refined community affiliation vector</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>optimized modularity metric</dd>
</dl>
<p>Note: Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_finetune_und">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_finetune_und</tt><big>(</big><em>W</em>, <em>ci=None</em>, <em>gamma=1</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_finetune_und" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges. 
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>This algorithm is inspired by the Kernighan-Lin fine-tuning algorithm
and is designed to refine a previously detected community structure.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected weighted/binary connection matrix</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray | None</span></dt>
<dd>initial community affiliation vector</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</dd>
<dt>seed <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>random seed. default value=None. if None, seeds from /dev/urandom.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>refined community affiliation vector</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>optimized modularity metric</dd>
</dl>
<p>Note: Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_finetune_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_finetune_und_sign</tt><big>(</big><em>W</em>, <em>qtype='sta'</em>, <em>ci=None</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_finetune_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges. 
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>This algorithm is inspired by the Kernighan-Lin fine-tuning algorithm
and is designed to refine a previously detected community structure.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected weighted/binary connection matrix with positive and
negative weights.</dd>
<dt>qtype <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>modularity type. Can be &#8216;sta&#8217; (default), &#8216;pos&#8217;, &#8216;smp&#8217;, &#8216;gja&#8217;, &#8216;neg&#8217;.
See Rubinov and Sporns (2011) for a description.</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray | None</span></dt>
<dd>initial community affiliation vector</dd>
<dt>seed <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>random seed. default value=None. if None, seeds from /dev/urandom.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>refined community affiliation vector</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>optimized modularity metric</dd>
</dl>
<p>Note: Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_louvain_dir">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_louvain_dir</tt><big>(</big><em>W</em>, <em>gamma=1</em>, <em>hierarchy=False</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_louvain_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>The Louvain algorithm is a fast and accurate community detection
algorithm (as of writing). The algorithm may also be used to detect
hierarchical community structure.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed weighted/binary connection matrix</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</dd>
<dt>hierarchy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Enables hierarchical output. Defalut value=False</dd>
<dt>seed <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>random seed. default value=None. if None, seeds from /dev/urandom.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>refined community affiliation vector. If hierarchical output enabled,
it is an NxH np.ndarray instead with multiple iterations</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>optimized modularity metric. If hierarchical output enabled, becomes
an Hx1 array of floats instead.</dd>
</dl>
<p>Note: Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_louvain_und">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_louvain_und</tt><big>(</big><em>W</em>, <em>gamma=1</em>, <em>hierarchy=False</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_louvain_und" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges. 
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>The Louvain algorithm is a fast and accurate community detection 
algorithm (as of writing). The algorithm may also be used to detect
hierarchical community structure.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected weighted/binary connection matrix</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</dd>
<dt>hierarchy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Enables hierarchical output. Defalut value=False</dd>
<dt>seed <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>random seed. default value=None. if None, seeds from /dev/urandom.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>refined community affiliation vector. If hierarchical output enabled,
it is an NxH np.ndarray instead with multiple iterations</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>optimized modularity metric. If hierarchical output enabled, becomes
an Hx1 array of floats instead.</dd>
</dl>
<p>Note: Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_louvain_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_louvain_und_sign</tt><big>(</big><em>W</em>, <em>qtype='sta'</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_louvain_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges. 
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<p>The Louvain algorithm is a fast and accurate community detection 
algorithm (at the time of writing).</p>
<p>Use this function as opposed to modularity_louvain_und() only if the
network contains a mix of positive and negative weights.  If the network
contains all positive weights, the output will be equivalent to that of
modularity_louvain_und().</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected weighted/binary connection matrix with positive and
negative weights</dd>
<dt>qtype <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>modularity type. Can be &#8216;sta&#8217; (default), &#8216;pos&#8217;, &#8216;smp&#8217;, &#8216;gja&#8217;, &#8216;neg&#8217;.
See Rubinov and Sporns (2011) for a description.</dd>
<dt>seed <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>random seed. default value=None. if None, seeds from /dev/urandom.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>refined community affiliation vector</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>optimized modularity metric</dd>
</dl>
<p>Note: Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_probtune_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_probtune_und_sign</tt><big>(</big><em>W</em>, <em>qtype='sta'</em>, <em>ci=None</em>, <em>p=0.45</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#bct.modularity_probtune_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges. 
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.
High-modularity degeneracy is the presence of many topologically
distinct high-modularity partitions of the network.</p>
<p>This algorithm is inspired by the Kernighan-Lin fine-tuning algorithm
and is designed to probabilistically refine a previously detected
community by incorporating random node moves into a finetuning
algorithm.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected weighted/binary connection matrix with positive and
negative weights</dd>
<dt>qtype <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>modularity type. Can be &#8216;sta&#8217; (default), &#8216;pos&#8217;, &#8216;smp&#8217;, &#8216;gja&#8217;, &#8216;neg&#8217;.
See Rubinov and Sporns (2011) for a description.</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray | None</span></dt>
<dd>initial community affiliation vector</dd>
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>probability of random node moves. Default value = 0.45</dd>
<dt>seed <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>random seed. default value=None. if None, seeds from /dev/urandom.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>refined community affiliation vector</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>optimized modularity metric</dd>
</dl>
<p>Note: Ci and Q may vary from run to run, due to heuristics in the
algorithm. Consequently, it may be worth to compare multiple runs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_und">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_und</tt><big>(</big><em>A</em>, <em>gamma=1</em>, <em>kci=None</em><big>)</big><a class="headerlink" href="#bct.modularity_und" title="Permalink to this definition">¶</a></dt>
<dd><p>The optimal community structure is a subdivision of the network into
nonoverlapping groups of nodes in a way that maximizes the number of
within-group edges, and minimizes the number of between-group edges.
The modularity is a statistic that quantifies the degree to which the
network may be subdivided into such clearly delineated groups.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected weighted/binary connection matrix</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>resolution parameter. default value=1. Values 0 &lt;= gamma &lt; 1 detect
larger modules while gamma &gt; 1 detects smaller modules.</dd>
<dt>kci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray | None</span></dt>
<dd>starting community structure. If specified, calculates the Q-metric
on the community structure giving, without doing any optimzation.
Otherwise, if not specified, uses a spectral modularity maximization
algorithm.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>optimized community structure</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>maximized modularity metric</dd>
</dl>
<p>Note: This algorithm is deterministic. The matlab function bearing this 
name incorrectly disclaims that the outcome depends on heuristics 
involving a random seed. The louvain method does depend on a random seed, 
but this function uses a deterministic modularity maximization algorithm.</p>
</dd></dl>

<dl class="function">
<dt id="bct.modularity_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">modularity_und_sign</tt><big>(</big><em>W</em>, <em>ci</em>, <em>qtype='sta'</em><big>)</big><a class="headerlink" href="#bct.modularity_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>This function simply calculates the signed modularity for a given 
partition. It does not do automatic partition generation right now.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected weighted/binary connection matrix with positive and
negative weights</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>community partition</dd>
<dt>qtype <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>modularity type. Can be &#8216;sta&#8217; (default), &#8216;pos&#8217;, &#8216;smp&#8217;, &#8216;gja&#8217;, &#8216;neg&#8217;.
See Rubinov and Sporns (2011) for a description.</dd>
</dl>
<dl class="docutils">
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>the partition which was input (for consistency of the API)</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>maximized modularity metric</dd>
</dl>
<p>Note: uses a deterministic algorithm</p>
</dd></dl>

<dl class="function">
<dt id="bct.module_degree_zscore">
<tt class="descclassname">bct.</tt><tt class="descname">module_degree_zscore</tt><big>(</big><em>W</em>, <em>ci</em>, <em>flag=0</em><big>)</big><a class="headerlink" href="#bct.module_degree_zscore" title="Permalink to this definition">¶</a></dt>
<dd><p>The within-module degree z-score is a within-module version of degree
centrality.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.narray</span></dt>
<dd>binary/weighted directed/undirected connection matrix</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.array_like</span></dt>
<dd>community affiliation vector</dd>
<dt>flag <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><dl class="first last docutils">
<dt>Graph type. 0: undirected graph (default)</dt>
<dd>1: directed graph in degree
2: directed graph out degree
3: directed graph in and out degree</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt>Z <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>within-module degree Z-score</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.motif3funct_bin">
<tt class="descclassname">bct.</tt><tt class="descname">motif3funct_bin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.motif3funct_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Functional motifs are subsets of connection patterns embedded within 
anatomical motifs. Motif frequency is the frequency of occurrence of 
motifs around a node.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed connection matrix</dd>
</dl>
<dl class="docutils">
<dt>F <span class="classifier-delimiter">:</span> <span class="classifier">13xN np.ndarray</span></dt>
<dd>motif frequency matrix</dd>
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">13x1 np.ndarray</span></dt>
<dd>motif frequency vector (averaged over all nodes)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.motif3funct_wei">
<tt class="descclassname">bct.</tt><tt class="descname">motif3funct_wei</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.motif3funct_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Functional motifs are subsets of connection patterns embedded within 
anatomical motifs. Motif frequency is the frequency of occurrence of 
motifs around a node. Motif intensity and coherence are weighted 
generalizations of motif frequency.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted directed connection matrix (all weights between 0 and 1)</dd>
</dl>
<dl class="docutils">
<dt>I <span class="classifier-delimiter">:</span> <span class="classifier">13xN np.ndarray</span></dt>
<dd>motif intensity matrix</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">13xN np.ndarray</span></dt>
<dd>motif coherence matrix</dd>
<dt>F <span class="classifier-delimiter">:</span> <span class="classifier">13xN np.ndarray</span></dt>
<dd>motif frequency matrix</dd>
</dl>
<p>Note: Average intensity and coherence are given by I./F and Q./F.</p>
</dd></dl>

<dl class="function">
<dt id="bct.motif3struct_bin">
<tt class="descclassname">bct.</tt><tt class="descname">motif3struct_bin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.motif3struct_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structural motifs are patterns of local connectivity. Motif frequency
is the frequency of occurrence of motifs around a node.</p>
<p>Input:      A,      binary directed connection matrix</p>
<dl class="docutils">
<dt>Output:     F,      motif frequency matrix</dt>
<dd>f,      motif frequency vector (averaged over all nodes)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.motif3struct_wei">
<tt class="descclassname">bct.</tt><tt class="descname">motif3struct_wei</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.motif3struct_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Structural motifs are patterns of local connectivity. Motif frequency
is the frequency of occurrence of motifs around a node. Motif intensity
and coherence are weighted generalizations of motif frequency.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted directed connection matrix (all weights between 0 and 1)</dd>
</dl>
<dl class="docutils">
<dt>I <span class="classifier-delimiter">:</span> <span class="classifier">13xN np.ndarray</span></dt>
<dd>motif intensity matrix</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">13xN np.ndarray</span></dt>
<dd>motif coherence matrix</dd>
<dt>F <span class="classifier-delimiter">:</span> <span class="classifier">13xN np.ndarray</span></dt>
<dd>motif frequency matrix</dd>
</dl>
<p>Note: Average intensity and coherence are given by I./F and Q./F.</p>
</dd></dl>

<dl class="function">
<dt id="bct.motif4funct_bin">
<tt class="descclassname">bct.</tt><tt class="descname">motif4funct_bin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.motif4funct_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Functional motifs are subsets of connection patterns embedded within 
anatomical motifs. Motif frequency is the frequency of occurrence of 
motifs around a node.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed connection matrix</dd>
</dl>
<dl class="docutils">
<dt>F <span class="classifier-delimiter">:</span> <span class="classifier">199xN np.ndarray</span></dt>
<dd>motif frequency matrix</dd>
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">199x1 np.ndarray</span></dt>
<dd>motif frequency vector (averaged over all nodes)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.motif4funct_wei">
<tt class="descclassname">bct.</tt><tt class="descname">motif4funct_wei</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.motif4funct_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Functional motifs are subsets of connection patterns embedded within 
anatomical motifs. Motif frequency is the frequency of occurrence of 
motifs around a node. Motif intensity and coherence are weighted 
generalizations of motif frequency.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted directed connection matrix (all weights between 0 and 1)</dd>
</dl>
<dl class="docutils">
<dt>I <span class="classifier-delimiter">:</span> <span class="classifier">199xN np.ndarray</span></dt>
<dd>motif intensity matrix</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">199xN np.ndarray</span></dt>
<dd>motif coherence matrix</dd>
<dt>F <span class="classifier-delimiter">:</span> <span class="classifier">199xN np.ndarray</span></dt>
<dd>motif frequency matrix</dd>
</dl>
<p>Note: Average intensity and coherence are given by I./F and Q./F.</p>
</dd></dl>

<dl class="function">
<dt id="bct.motif4struct_bin">
<tt class="descclassname">bct.</tt><tt class="descname">motif4struct_bin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.motif4struct_bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Structural motifs are patterns of local connectivity. Motif frequency
is the frequency of occurrence of motifs around a node.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed connection matrix</dd>
</dl>
<dl class="docutils">
<dt>F <span class="classifier-delimiter">:</span> <span class="classifier">199xN np.ndarray</span></dt>
<dd>motif frequency matrix</dd>
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">199x1 np.ndarray</span></dt>
<dd>motif frequency vector (averaged over all nodes)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.motif4struct_wei">
<tt class="descclassname">bct.</tt><tt class="descname">motif4struct_wei</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.motif4struct_wei" title="Permalink to this definition">¶</a></dt>
<dd><p>Structural motifs are patterns of local connectivity. Motif frequency
is the frequency of occurrence of motifs around a node. Motif intensity
and coherence are weighted generalizations of motif frequency.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted directed connection matrix (all weights between 0 and 1)</dd>
</dl>
<dl class="docutils">
<dt>I <span class="classifier-delimiter">:</span> <span class="classifier">199xN np.ndarray</span></dt>
<dd>motif intensity matrix</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">199xN np.ndarray</span></dt>
<dd>motif coherence matrix</dd>
<dt>F <span class="classifier-delimiter">:</span> <span class="classifier">199xN np.ndarray</span></dt>
<dd>motif frequency matrix</dd>
</dl>
<p>Note: Average intensity and coherence are given by I./F and Q./F.</p>
</dd></dl>

<dl class="function">
<dt id="bct.normalize">
<tt class="descclassname">bct.</tt><tt class="descname">normalize</tt><big>(</big><em>W</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes an input weighted connection matrix.  If copy is not set, this
function will <em>modify W in place.</em></p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>weighted connectivity matrix</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</dd>
</dl>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>normalized connectivity matrix</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.null_model_dir_sign">
<tt class="descclassname">bct.</tt><tt class="descname">null_model_dir_sign</tt><big>(</big><em>W</em>, <em>bin_swaps=5</em>, <em>wei_freq=0.1</em><big>)</big><a class="headerlink" href="#bct.null_model_dir_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes an directed network with positive and
negative weights, while preserving the degree and strength
distributions. This function calls randmio_dir.m</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed weighted connection matrix</dd>
<dt>bin_swaps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>average number of swaps in each edge binary randomization. Default
value is 5. 0 swaps implies no binary randomization.</dd>
<dt>wei_freq <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first">frequency of weight sorting in weighted randomization. 0&lt;=wei_freq&lt;1.
wei_freq == 1 implies that weights are sorted at each step.
wei_freq == 0.1 implies that weights sorted each 10th step (faster,</p>
<blockquote>
<div>default value)</div></blockquote>
<p class="last">wei_freq == 0 implies no sorting of weights (not recommended)</p>
</dd>
</dl>
<dl class="docutils">
<dt>W0 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>randomized weighted connection matrix</dd>
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">4-tuple of floats</span></dt>
<dd>Correlation coefficients between strength sequences of input and
output connection matrices, rpos_in, rpos_out, rneg_in, rneg_out</dd>
<dt>Notes:</dt>
<dd>The value of bin_swaps is ignored when binary topology is fully</dd>
<dt>connected (e.g. when the network has no negative weights).</dt>
<dd>Randomization may be better (and execution time will be slower) for</dd>
</dl>
<p>higher values of bin_swaps and wei_freq. Higher values of bin_swaps may
enable a more random binary organization, and higher values of wei_freq
may enable a more accurate conservation of strength sequences.</p>
<blockquote>
<div>R are the correlation coefficients between positive and negative</div></blockquote>
<p>in-strength and out-strength sequences of input and output connection
matrices and are used to evaluate the accuracy with which strengths
were preserved. Note that correlation coefficients may be a rough
measure of strength-sequence accuracy and one could implement more
formal tests (such as the Kolmogorov-Smirnov test) if desired.</p>
</dd></dl>

<dl class="function">
<dt id="bct.null_model_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">null_model_und_sign</tt><big>(</big><em>W</em>, <em>bin_swaps=5</em>, <em>wei_freq=0.1</em><big>)</big><a class="headerlink" href="#bct.null_model_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes an undirected network with positive and
negative weights, while preserving the degree and strength
distributions. This function calls randmio_und.m</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected weighted connection matrix</dd>
<dt>bin_swaps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>average number of swaps in each edge binary randomization. Default
value is 5. 0 swaps implies no binary randomization.</dd>
<dt>wei_freq <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first">frequency of weight sorting in weighted randomization. 0&lt;=wei_freq&lt;1.
wei_freq == 1 implies that weights are sorted at each step.
wei_freq == 0.1 implies that weights sorted each 10th step (faster,</p>
<blockquote>
<div>default value)</div></blockquote>
<p class="last">wei_freq == 0 implies no sorting of weights (not recommended)</p>
</dd>
</dl>
<dl class="docutils">
<dt>W0 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>randomized weighted connection matrix</dd>
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">4-tuple of floats</span></dt>
<dd>Correlation coefficients between strength sequences of input and
output connection matrices, rpos_in, rpos_out, rneg_in, rneg_out</dd>
</dl>
<p>Notes:
The value of bin_swaps is ignored when binary topology is fully</p>
<blockquote>
<div>connected (e.g. when the network has no negative weights).</div></blockquote>
<dl class="docutils">
<dt>Randomization may be better (and execution time will be slower) for</dt>
<dd>higher values of bin_swaps and wei_freq. Higher values of bin_swaps 
may enable a more random binary organization, and higher values of 
wei_freq may enable a more accurate conservation of strength 
sequences.</dd>
<dt>R are the correlation coefficients between positive and negative</dt>
<dd>strength sequences of input and output connection matrices and are
used to evaluate the accuracy with which strengths were preserved. 
Note that correlation coefficients may be a rough measure of
strength-sequence accuracy and one could implement more formal tests
(such as the Kolmogorov-Smirnov test) if desired.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.number_of_components">
<tt class="descclassname">bct.</tt><tt class="descname">number_of_components</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.number_of_components" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bct.pagerank_centrality">
<tt class="descclassname">bct.</tt><tt class="descname">pagerank_centrality</tt><big>(</big><em>A</em>, <em>d</em>, <em>falff=None</em><big>)</big><a class="headerlink" href="#bct.pagerank_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>The PageRank centrality is a variant of eigenvector centrality. This
function computes the PageRank centrality of each vertex in a graph.</p>
<p>Formally, PageRank is defined as the stationary distribution achieved
by instantiating a Markov chain on a graph. The PageRank centrality of
a given vertex, then, is proportional to the number of steps (or amount
of time) spent at that vertex as a result of such a process.</p>
<p>The PageRank index gets modified by the addition of a damping factor,
d. In terms of a Markov chain, the damping factor specifies the
fraction of the time that a random walker will transition to one of its
current state&#8217;s neighbors. The remaining fraction of the time the
walker is restarted at a random vertex. A common value for the damping
factor is d = 0.85.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.narray</span></dt>
<dd>adjacency matrix</dd>
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>damping factor (see description)</dd>
<dt>falff <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray | None</span></dt>
<dd>Initial page rank probability, non-negative values. Default value is
None. If not specified, a naive bayesian prior is used.</dd>
</dl>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>vectors of page rankings</dd>
</dl>
<p>Note: The algorithm will work well for smaller matrices (number of
nodes around 1000 or less)</p>
</dd></dl>

<dl class="function">
<dt id="bct.participation_coef">
<tt class="descclassname">bct.</tt><tt class="descname">participation_coef</tt><big>(</big><em>W</em>, <em>ci</em>, <em>degree='undirected'</em><big>)</big><a class="headerlink" href="#bct.participation_coef" title="Permalink to this definition">¶</a></dt>
<dd><p>Participation coefficient is a measure of diversity of intermodular
connections of individual nodes.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary/weighted directed/undirected connection matrix</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>community affiliation vector</dd>
<dt>degree <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><dl class="first last docutils">
<dt>Flag to describe nature of graph &#8216;undirected&#8217;: For undirected graphs</dt>
<dd>&#8216;in&#8217;: Uses the in-degree
&#8216;out&#8217;: Uses the out-degree</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt>P <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>participation coefficient</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.participation_coef_sign">
<tt class="descclassname">bct.</tt><tt class="descname">participation_coef_sign</tt><big>(</big><em>W</em>, <em>ci</em><big>)</big><a class="headerlink" href="#bct.participation_coef_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Participation coefficient is a measure of diversity of intermodular
connections of individual nodes.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected connection matrix with positive and negative weights</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>community affiliation vector</dd>
</dl>
<dl class="docutils">
<dt>Ppos <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>participation coefficient from positive weights</dd>
<dt>Pneg <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>participation coefficient from negative weights</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.partition_distance">
<tt class="descclassname">bct.</tt><tt class="descname">partition_distance</tt><big>(</big><em>cx</em>, <em>cy</em><big>)</big><a class="headerlink" href="#bct.partition_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>This function quantifies the distance between pairs of community
partitions with information theoretic measures.</p>
<dl class="docutils">
<dt>cx <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>community affiliation vector X</dd>
<dt>cy <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>community affiliation vector Y</dd>
</dl>
<dl class="docutils">
<dt>VIn <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>normalized variation of information</dd>
<dt>MIn <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>normalized mutual information</dd>
<dt>(Definitions:</dt>
<dd>VIn = [H(X) + H(Y) - 2MI(X,Y)]/log(n)
MIn = 2MI(X,Y)/[H(X)+H(Y)]</dd>
</dl>
<p>where H is entropy, MI is mutual information and n is number of nodes)</p>
</dd></dl>

<dl class="function">
<dt id="bct.randmio_dir">
<tt class="descclassname">bct.</tt><tt class="descname">randmio_dir</tt><big>(</big><em>R</em>, <em>iter</em><big>)</big><a class="headerlink" href="#bct.randmio_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes a directed network, while preserving the in-
and out-degree distributions. In weighted networks, the function
preserves the out-strength but not the in-strength distributions.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed binary/weighted connection matrix</dd>
<dt>iter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>rewiring parameter. Each edge is rewired approximately iter times.</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>randomized network</dd>
<dt>eff <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of actual rewirings carried out</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.randmio_dir_connected">
<tt class="descclassname">bct.</tt><tt class="descname">randmio_dir_connected</tt><big>(</big><em>R</em>, <em>iter</em><big>)</big><a class="headerlink" href="#bct.randmio_dir_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes a directed network, while preserving the in-
and out-degree distributions. In weighted networks, the function
preserves the out-strength but not the in-strength distributions. The
function also ensures that the randomized network maintains
connectedness, the ability for every node to reach every other node in
the network. The input network for this function must be connected.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed binary/weighted connection matrix</dd>
<dt>iter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>rewiring parameter. Each edge is rewired approximately iter times.</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>randomized network</dd>
<dt>eff <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of actual rewirings carried out</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.randmio_und">
<tt class="descclassname">bct.</tt><tt class="descname">randmio_und</tt><big>(</big><em>R</em>, <em>iter</em><big>)</big><a class="headerlink" href="#bct.randmio_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes an undirected network, while preserving the 
degree distribution. The function does not preserve the strength 
distribution in weighted networks.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected binary/weighted connection matrix</dd>
<dt>iter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>rewiring parameter. Each edge is rewired approximately iter times.</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>randomized network</dd>
<dt>eff <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of actual rewirings carried out</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.randmio_und_connected">
<tt class="descclassname">bct.</tt><tt class="descname">randmio_und_connected</tt><big>(</big><em>R</em>, <em>iter</em><big>)</big><a class="headerlink" href="#bct.randmio_und_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes an undirected network, while preserving the 
degree distribution. The function does not preserve the strength 
distribution in weighted networks. The function also ensures that the 
randomized network maintains connectedness, the ability for every node 
to reach every other node in the network. The input network for this 
function must be connected.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected binary/weighted connection matrix</dd>
<dt>iter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>rewiring parameter. Each edge is rewired approximately iter times.</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>randomized network</dd>
<dt>eff <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of actual rewirings carried out</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.randmio_und_signed">
<tt class="descclassname">bct.</tt><tt class="descname">randmio_und_signed</tt><big>(</big><em>R</em>, <em>iter</em><big>)</big><a class="headerlink" href="#bct.randmio_und_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes an undirected weighted network with positive
and negative weights, while simultaneously preserving the degree 
distribution of positive and negative weights. The function does not 
preserve the strength distribution in weighted networks.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected binary/weighted connection matrix</dd>
<dt>iter <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>rewiring parameter. Each edge is rewired approximately iter times.</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>randomized network</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.randomize_graph_partial_und">
<tt class="descclassname">bct.</tt><tt class="descname">randomize_graph_partial_und</tt><big>(</big><em>A</em>, <em>B</em>, <em>maxswap</em><big>)</big><a class="headerlink" href="#bct.randomize_graph_partial_und" title="Permalink to this definition">¶</a></dt>
<dd><p>A = RANDOMIZE_GRAPH_PARTIAL_UND(A,B,MAXSWAP) takes adjacency matrices A 
and B and attempts to randomize matrix A by performing MAXSWAP 
rewirings. The rewirings will avoid any spots where matrix B is 
nonzero.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected adjacency matrix to randomize</dd>
<dt>B <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>mask; edges to avoid</dd>
<dt>maxswap <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of rewirings</dd>
</dl>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>randomized matrix</dd>
</dl>
<p>Notes:
1. Graph may become disconnected as a result of rewiring. Always</p>
<blockquote>
<div>important to check.</div></blockquote>
<ol class="arabic simple" start="2">
<li>A can be weighted, though the weighted degree sequence will not be</li>
</ol>
<blockquote>
<div>preserved.</div></blockquote>
<ol class="arabic simple" start="3">
<li>A must be undirected.</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="bct.randomizer_bin_und">
<tt class="descclassname">bct.</tt><tt class="descname">randomizer_bin_und</tt><big>(</big><em>R</em>, <em>alpha</em><big>)</big><a class="headerlink" href="#bct.randomizer_bin_und" title="Permalink to this definition">¶</a></dt>
<dd><p>This function randomizes a binary undirected network, while preserving 
the degree distribution. The function directly searches for rewirable 
edge pairs (rather than trying to rewire edge pairs at random), and 
hence avoids long loops and works especially well in dense matrices.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary undirected connection matrix</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>fraction of edges to rewire</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>randomized network</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.reachdist">
<tt class="descclassname">bct.</tt><tt class="descname">reachdist</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.reachdist" title="Permalink to this definition">¶</a></dt>
<dd><p>The binary reachability matrix describes reachability between all pairs</p>
<p>of nodes. An entry (u,v)=1 means that there exists a path from node u
to node v; alternatively (u,v)=0.</p>
<p>The distance matrix contains lengths of shortest paths between all
pairs of nodes. An entry (u,v) represents the length of shortest path 
from node u to  node v. The average shortest path length is the 
characteristic path length of the network.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed/undirected connection matrix</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary reachability matrix</dd>
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>distance matrix</dd>
</dl>
<p>Note: faster but more memory intensive than &#8220;breadthdist.m&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="bct.rentian_scaling">
<tt class="descclassname">bct.</tt><tt class="descname">rentian_scaling</tt><big>(</big><em>A</em>, <em>xyz</em>, <em>n</em><big>)</big><a class="headerlink" href="#bct.rentian_scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Physical Rentian scaling (or more simply Rentian scaling) is a property 
of systems that are cost-efficiently embedded into physical space. It is 
what is called a &#8220;topo-physical&#8221; property because it combines information 
regarding the topological organization of the graph with information 
about the physical placement of connections. Rentian scaling is present 
in very large scale integrated circuits, the C. elegans neuronal network, 
and morphometric and diffusion-based graphs of human anatomical networks.
Rentian scaling is determined by partitioning the system into cubes, 
counting the number of nodes inside of each cube (N), and the number of 
edges traversing the boundary of each cube (E). If the system displays 
Rentian scaling, these two variables N and E will scale with one another 
in loglog space. The Rent&#8217;s exponent is given by the slope of log10(E) 
vs. log10(N), and can be reported alone or can be compared to the 
theoretical minimum Rent&#8217;s exponent to determine how cost efficiently the 
network has been embedded into physical space. Note: if a system displays 
Rentian scaling, it does not automatically mean that the system is 
cost-efficiently embedded (although it does suggest that). Validation 
occurs when comparing to the theoretical minimum Rent&#8217;s exponent for that
system.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>unweighted, binary, symmetric adjacency matrix</dd>
<dt>xyz <span class="classifier-delimiter">:</span> <span class="classifier">Nx3 np.ndarray</span></dt>
<dd>vector of node placement coordinates</dd>
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of partitions to compute. Each partition is a data point; you
want a large enough number to adequately compute Rent&#8217;s exponent.</dd>
</dl>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">Mx1 np.ndarray</span></dt>
<dd>Number of nodes in each of the M partitions</dd>
</dl>
<p>E : Mx1 np.ndarray</p>
<p>Subsequent Analysis:
Rentian scaling plots are then created by: figure; loglog(E,N,&#8217;*&#8217;);
To determine the Rent&#8217;s exponent, p, it is important not to use 
partitions which may 
be affected by boundary conditions. In Bassett et al. 2010 PLoS CB, only 
partitions with N&lt;M/2 were used in the estimation of the Rent&#8217;s exponent. 
Thus, we can define N_prime = N(find(N&lt;M/2)) and 
E_prime = E(find(N&lt;M/2)). 
Next we need to determine the slope of Eprime vs. Nprime in loglog space, 
which is the Rent&#8217;s 
exponent. There are many ways of doing this with more or less statistical 
rigor. Robustfit in MATLAB is one such option:</p>
<blockquote>
<div>[b,stats] = robustfit(log10(N_prime),log10(E_prime))</div></blockquote>
<p>Then the Rent&#8217;s exponent is b(1,2) and the standard error of the
estimation is given by stats.se(1,2).</p>
<p>Note: n=5000 was used in Bassett et al. 2010 in PLoS CB.</p>
</dd></dl>

<dl class="function">
<dt id="bct.reorderMAT">
<tt class="descclassname">bct.</tt><tt class="descname">reorderMAT</tt><big>(</big><em>m</em>, <em>H=5000</em>, <em>cost='line'</em><big>)</big><a class="headerlink" href="#bct.reorderMAT" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reorders the connectivity matrix in order to place more
edges closer to the diagonal. This often helps in displaying community
structure, clusters, etc.</p>
<dl class="docutils">
<dt>MAT <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix</dd>
<dt>H <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of reordering attempts</dd>
<dt>cost <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>&#8216;line&#8217; or &#8216;circ&#8217; for shape of lattice (linear or ring lattice).
Default is linear lattice.</dd>
</dl>
<dl class="docutils">
<dt>MATreordered <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>reordered connection matrix</dd>
<dt>MATindices <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>reordered indices</dd>
<dt>MATcost <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>objective function cost of reordered matrix</dd>
</dl>
<p>Note: I&#8217;m not 100% sure how the algorithms between this and reorder_matrix
differ, but this code looks a ton sketchier and might have had some minor
bugs in it.  Considering reorder_matrix() does the same thing using a well
vetted simulated annealing algorithm, just use that. ~rlaplant</p>
</dd></dl>

<dl class="function">
<dt id="bct.reorder_matrix">
<tt class="descclassname">bct.</tt><tt class="descname">reorder_matrix</tt><big>(</big><em>m1</em>, <em>cost='line'</em>, <em>verbose=False</em>, <em>H=10000.0</em>, <em>Texp=10</em>, <em>T0=0.001</em>, <em>Hbrk=10</em><big>)</big><a class="headerlink" href="#bct.reorder_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This function rearranges the nodes in matrix M1 such that the matrix
elements are squeezed along the main diagonal.  The function uses a
version of simulated annealing.</p>
<dl class="docutils">
<dt>M1 <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix weighted/binary directed/undirected</dd>
<dt>cost <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>&#8216;line&#8217; or &#8216;circ&#8217; for shape of lattice (linear or ring lattice).
Default is linear lattice.</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>print out cost at each iteration. Default False.</dd>
<dt>H <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>annealing parameter, default value 1e6</dd>
<dt>Texp <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>annealing parameter, default value 1. Coefficient of H s.t. 
Texp0=1-Texp/H</dd>
<dt>T0 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>annealing parameter, default value 1e-3</dd>
<dt>Hbrk <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>annealing parameter, default value = 10. Coefficient of H s.t.
Hbrk0 = H/Hkbr</dd>
</dl>
<dl class="docutils">
<dt>Mreordered <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>reordered connection matrix</dd>
<dt>Mindices <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>reordered indices</dd>
<dt>Mcost <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>objective function cost of reordered matrix</dd>
</dl>
<p>Note that in general, the outcome will depend on the initial condition
(the setting of the random number seed).  Also, there is no good way to 
determine optimal annealing parameters in advance - these paramters 
will need to be adjusted &#8220;by hand&#8221; (particularly H, Texp, and T0).  
For large and/or dense matrices, it is highly recommended to perform 
exploratory runs varying the settings of &#8216;H&#8217; and &#8216;Texp&#8217; and then select 
the best values.</p>
<p>Based on extensive testing, it appears that T0 and Hbrk can remain
unchanged in most cases.  Texp may be varied from 1-1/H to 1-10/H, for
example.  H is the most important parameter - set to larger values as
the problem size increases.  It is advisable to run this function
multiple times and select the solution(s) with the lowest &#8216;cost&#8217;.</p>
<p>Setting &#8216;Texp&#8217; to zero cancels annealing and uses a greedy algorithm
instead.</p>
</dd></dl>

<dl class="function">
<dt id="bct.reorder_mod">
<tt class="descclassname">bct.</tt><tt class="descname">reorder_mod</tt><big>(</big><em>A</em>, <em>ci</em><big>)</big><a class="headerlink" href="#bct.reorder_mod" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reorders the connectivity matrix by modular structure and
may hence be useful in visualization of modular structure.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary/weighted connectivity matrix</dd>
<dt>ci <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>module affiliation vector</dd>
</dl>
<dl class="docutils">
<dt>On <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>new node order</dd>
<dt>Ar <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>reordered connectivity matrix</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.rich_club_bd">
<tt class="descclassname">bct.</tt><tt class="descname">rich_club_bd</tt><big>(</big><em>CIJ</em>, <em>klevel=None</em><big>)</big><a class="headerlink" href="#bct.rich_club_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>The rich club coefficient, R, at level k is the fraction of edges that
connect nodes of degree k or higher out of the maximum number of edges
that such nodes might share.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed connection matrix</dd>
<dt>klevel <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>sets the maximum level at which the rich club coefficient will be
calculated. If None (default), the maximum level is set to the
maximum degree of the adjacency matrix</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">Kx1 np.ndarray</span></dt>
<dd>vector of rich-club coefficients for levels 1 to klevel</dd>
<dt>Nk <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of nodes with degree &gt; k</dd>
<dt>Ek <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of edges remaining in subgraph with degree &gt; k</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.rich_club_bu">
<tt class="descclassname">bct.</tt><tt class="descname">rich_club_bu</tt><big>(</big><em>CIJ</em>, <em>klevel=None</em><big>)</big><a class="headerlink" href="#bct.rich_club_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>The rich club coefficient, R, at level k is the fraction of edges that
connect nodes of degree k or higher out of the maximum number of edges
that such nodes might share.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary undirected connection matrix</dd>
<dt>klevel <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>sets the maximum level at which the rich club coefficient will be
calculated. If None (default), the maximum level is set to the
maximum degree of the adjacency matrix</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">Kx1 np.ndarray</span></dt>
<dd>vector of rich-club coefficients for levels 1 to klevel</dd>
<dt>Nk <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of nodes with degree &gt; k</dd>
<dt>Ek <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of edges remaining in subgraph with degree &gt; k</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.rich_club_wd">
<tt class="descclassname">bct.</tt><tt class="descname">rich_club_wd</tt><big>(</big><em>CIJ</em>, <em>klevel=None</em><big>)</big><a class="headerlink" href="#bct.rich_club_wd" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted directed connection matrix</dd>
<dt>klevel <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>sets the maximum level at which the rich club coefficient will be
calculated. If None (default), the maximum level is set to the
maximum degree of the adjacency matrix</dd>
</dl>
<dl class="docutils">
<dt>Rw <span class="classifier-delimiter">:</span> <span class="classifier">Kx1 np.ndarray</span></dt>
<dd>vector of rich-club coefficients for levels 1 to klevel</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.rich_club_wu">
<tt class="descclassname">bct.</tt><tt class="descname">rich_club_wu</tt><big>(</big><em>CIJ</em>, <em>klevel=None</em><big>)</big><a class="headerlink" href="#bct.rich_club_wu" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted undirected connection matrix</dd>
<dt>klevel <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd>sets the maximum level at which the rich club coefficient will be
calculated. If None (default), the maximum level is set to the
maximum degree of the adjacency matrix</dd>
</dl>
<dl class="docutils">
<dt>Rw <span class="classifier-delimiter">:</span> <span class="classifier">Kx1 np.ndarray</span></dt>
<dd>vector of rich-club coefficients for levels 1 to klevel</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.score_wu">
<tt class="descclassname">bct.</tt><tt class="descname">score_wu</tt><big>(</big><em>CIJ</em>, <em>s</em><big>)</big><a class="headerlink" href="#bct.score_wu" title="Permalink to this definition">¶</a></dt>
<dd><p>The s-core is the largest subnetwork comprising nodes of strength at
least s. This function computes the s-core for a given weighted
undirected connection matrix. Computation is analogous to the more
widely used k-core, but is based on node strengths instead of node
degrees.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted undirected connection matrix</dd>
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>level of s-core. Note that can take on any fractional value.</dd>
</dl>
<dl class="docutils">
<dt>CIJscore <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connection matrix of the s-core. This matrix contains only nodes with
a strength of at least s.</dd>
<dt>sn <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>size of s-core</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.strengths_dir">
<tt class="descclassname">bct.</tt><tt class="descname">strengths_dir</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.strengths_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Node strength is the sum of weights of links connected to the node. The
instrength is the sum of inward link weights and the outstrength is the
sum of outward link weights.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>directed weighted connection matrix</dd>
</dl>
<dl class="docutils">
<dt>is <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node in-strength</dd>
<dt>os <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node out-strength</dd>
<dt>str <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node strength (in-strength + out-strength)</dd>
</dl>
<p>Notes:  Inputs are assumed to be on the columns of the CIJ matrix.</p>
</dd></dl>

<dl class="function">
<dt id="bct.strengths_und">
<tt class="descclassname">bct.</tt><tt class="descname">strengths_und</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.strengths_und" title="Permalink to this definition">¶</a></dt>
<dd><p>Node strength is the sum of weights of links connected to the node.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected weighted connection matrix</dd>
</dl>
<dl class="docutils">
<dt>str <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>node strengths</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.strengths_und_sign">
<tt class="descclassname">bct.</tt><tt class="descname">strengths_und_sign</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.strengths_und_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Node strength is the sum of weights of links connected to the node.</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>undirected connection matrix with positive and negative weights</dd>
</dl>
<dl class="docutils">
<dt>Spos <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>nodal strength of positive weights</dd>
<dt>Sneg <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>nodal strength of positive weights</dd>
<dt>vpos <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>total positive weight</dd>
<dt>vneg <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>total negative weight</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.subgraph_centrality">
<tt class="descclassname">bct.</tt><tt class="descname">subgraph_centrality</tt><big>(</big><em>CIJ</em><big>)</big><a class="headerlink" href="#bct.subgraph_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>The subgraph centrality of a node is a weighted sum of closed walks of
different lengths in the network starting and ending at the node. This
function returns a vector of subgraph centralities for each node of the
network.</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary adjacency matrix</dd>
<dt>Cs <span class="classifier-delimiter">:</span> <span class="classifier">Nx1 np.ndarray</span></dt>
<dd>subgraph centrality</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.threshold_absolute">
<tt class="descclassname">bct.</tt><tt class="descname">threshold_absolute</tt><big>(</big><em>W</em>, <em>thr</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.threshold_absolute" title="Permalink to this definition">¶</a></dt>
<dd><p>This function thresholds the connectivity matrix by absolute weight
magnitude. All weights below the given threshold, and all weights
on the main diagonal (self-self connections) are set to 0.</p>
<p>If copy is not set, this function will <em>modify W in place.</em></p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>weighted connectivity matrix</dd>
<dt>thr <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>absolute weight threshold</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</dd>
</dl>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>thresholded connectivity matrix</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.threshold_proportional">
<tt class="descclassname">bct.</tt><tt class="descname">threshold_proportional</tt><big>(</big><em>W</em>, <em>p</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.threshold_proportional" title="Permalink to this definition">¶</a></dt>
<dd><p>This function &#8220;thresholds&#8221; the connectivity matrix by preserving a
proportion p (0&lt;p&lt;1) of the strongest weights. All other weights, and
all weights on the main diagonal (self-self connections) are set to 0.</p>
<p>If copy is not set, this function will <em>modify W in place.</em></p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>weighted connectivity matrix</dd>
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>proportional weight threshold (0&lt;p&lt;1)</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</dd>
</dl>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>thresholded connectivity matrix</dd>
</dl>
<p>Note: The proportion of elements set to 0 is a fraction of all elements 
in the matrix, whether or not they are already 0. That is, this function 
has the following behavior:</p>
<p>&gt;&gt; x = np.random.random((10,10))
&gt;&gt; x_25 = threshold_proportional(x, .25)
&gt;&gt; np.size(np.where(x_25)) #note this double counts each nonzero element
46
&gt;&gt; x_125 = threshold_proportional(x, .125)
&gt;&gt; np.size(np.where(x_125))
22
&gt;&gt; x_test = threshold_proportional(x_25, .5)
&gt;&gt; np.size(np.where(x_test))
46</p>
<p>That is, the 50% thresholding of x_25 does nothing because &gt;=50% of the 
elements in x_25 are aleady &lt;=0. This behavior is the same as in BCT. Be 
careful with matrices that are both signed and sparse.</p>
</dd></dl>

<dl class="function">
<dt id="bct.transitivity_bd">
<tt class="descclassname">bct.</tt><tt class="descname">transitivity_bd</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.transitivity_bd" title="Permalink to this definition">¶</a></dt>
<dd><p>Transitivity is the ratio of &#8216;triangles to triplets&#8217; in the network.
(A classical version of the clustering coefficient).</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary directed connection matrix</dd>
</dl>
<dl class="docutils">
<dt>T <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>transitivity scalar</dd>
</dl>
<p>Methodological note: In directed graphs, 3 nodes generate up to 8 
triangles (2*2*2 edges). The number of existing triangles is the main 
diagonal of S^3/2. The number of all (in or out) neighbour pairs is 
K(K-1)/2. Each neighbour pair may generate two triangles. &#8220;False pairs&#8221;
are i&lt;-&gt;j edge pairs (these do not generate triangles). The number of 
false pairs is the main diagonal of A^2. Thus the maximum possible 
number of triangles = (2 edges)*([ALL PAIRS] - [FALSE PAIRS])</p>
<blockquote>
<div>= 2 * (K(K-1)/2 - diag(A^2))
= K(K-1) - 2(diag(A^2))</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="bct.transitivity_bu">
<tt class="descclassname">bct.</tt><tt class="descname">transitivity_bu</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#bct.transitivity_bu" title="Permalink to this definition">¶</a></dt>
<dd><p>Transitivity is the ratio of &#8216;triangles to triplets&#8217; in the network.
(A classical version of the clustering coefficient).</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>binary undirected connection matrix</dd>
</dl>
<dl class="docutils">
<dt>T <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>transitivity scalar</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.transitivity_wd">
<tt class="descclassname">bct.</tt><tt class="descname">transitivity_wd</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.transitivity_wd" title="Permalink to this definition">¶</a></dt>
<dd><p>Transitivity is the ratio of &#8216;triangles to triplets&#8217; in the network.
(A classical version of the clustering coefficient).</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted directed connection matrix</dd>
</dl>
<dl class="docutils">
<dt>T <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>transitivity scalar</dd>
</dl>
<p>Methodological note (also see note for clustering_coef_bd)
The weighted modification is as follows:
- The numerator: adjacency matrix is replaced with weights matrix ^ 1/3
- The denominator: no changes from the binary version</p>
<p>The above reduces to symmetric and/or binary versions of the clustering
coefficient for respective graphs.</p>
</dd></dl>

<dl class="function">
<dt id="bct.transitivity_wu">
<tt class="descclassname">bct.</tt><tt class="descname">transitivity_wu</tt><big>(</big><em>W</em><big>)</big><a class="headerlink" href="#bct.transitivity_wu" title="Permalink to this definition">¶</a></dt>
<dd><p>Transitivity is the ratio of &#8216;triangles to triplets&#8217; in the network.
(A classical version of the clustering coefficient).</p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted undirected connection matrix</dd>
</dl>
<dl class="docutils">
<dt>T <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>transitivity scalar</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bct.weight_conversion">
<tt class="descclassname">bct.</tt><tt class="descname">weight_conversion</tt><big>(</big><em>W</em>, <em>wcm</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#bct.weight_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>W_bin = weight_conversion(W, &#8216;binarize&#8217;);
W_nrm = weight_conversion(W, &#8216;normalize&#8217;);
L = weight_conversion(W, &#8216;lengths&#8217;);</p>
<p>This function may either binarize an input weighted connection matrix,
normalize an input weighted connection matrix or convert an input
weighted connection matrix to a weighted connection-length matrix.</p>
<p>Binarization converts all present connection weights to 1.</p>
<p>Normalization scales all weight magnitudes to the range [0,1] and
should be done prior to computing some weighted measures, such as the
weighted clustering coefficient.</p>
<p>Conversion of connection weights to connection lengths is needed
prior to computation of weighted distance-based measures, such as
distance and betweenness centrality. In a weighted connection network,
higher weights are naturally interpreted as shorter lengths. The
connection-lengths matrix here is defined as the inverse of the
connection-weights matrix.</p>
<p>If copy is not set, this function will <em>modify W in place.</em></p>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>weighted connectivity matrix</dd>
<dt>wcm <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>weight conversion command.
&#8216;binarize&#8217; : binarize weights
&#8216;normalize&#8217; : normalize weights
&#8216;lengths&#8217; : convert weights to lengths (invert matrix)</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returns a copy of the matrix. Otherwise, modifies the matrix
in place. Default value=True.</dd>
</dl>
<dl class="docutils">
<dt>W <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>connectivity matrix with specified changes</dd>
</dl>
<p>Note: This function is included for compatibility with BCT. But there are
other functions binarize(), normalize() and invert() which are simpler to
call directly.</p>
</dd></dl>

<dl class="function">
<dt id="bct.writetoPAJ">
<tt class="descclassname">bct.</tt><tt class="descname">writetoPAJ</tt><big>(</big><em>CIJ</em>, <em>fname</em>, <em>directed</em><big>)</big><a class="headerlink" href="#bct.writetoPAJ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function writes a Pajek .net file from a numpy matrix</p>
<dl class="docutils">
<dt>CIJ <span class="classifier-delimiter">:</span> <span class="classifier">NxN np.ndarray</span></dt>
<dd>adjacency matrix</dd>
<dt>fname <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>filename</dd>
<dt>directed <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>True if the network is directed and False otherwise. The data format
may be required to know this for some reason so I am afraid to just
use directed as the default value.</dd>
</dl>
<p>None</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">bct package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#bct-bct-module">bct.bct module</a></li>
<li><a class="reference internal" href="#bct-nbs-module">bct.nbs module</a></li>
<li><a class="reference internal" href="#module-bct">Module contents</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/bct.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">bct 0.4 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, rlaplant.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>